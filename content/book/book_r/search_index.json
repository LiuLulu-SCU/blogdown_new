[["index.html", "R语言编程 简介", " R语言编程 刘卢路 2021年11月5日 简介 本书是R的百科全书，基于张敬信老师《R语言编程— 基于tidyverse》，李东风老师的《R语言教程》，和谢益辉《R Markdown: The Definitive Guide》，并结合自己科研工作中对R的理解。 "],["前言.html", "1 前言 1.1 ", " 1 前言 1.1 "],["基础语法.html", "2 基础语法 2.1 数据结构 2.2 控制结构 2.3 apply函数组 2.4 自定义函数", " 2 基础语法 2.1 数据结构 2.1.1 向量（一维数据） 2.1.1.1 向量的创建方式 2.1.1.1.1 直接创建 x = 2 y = &quot;I love Chnia&quot; 2.1.1.1.2 使用冒号（:）创建连续数值型向量 x = 1:10 2.1.1.1.3 使用c()函数创建向量 v1 &lt;- c(1,3,4,9,10) v2 &lt;- c(&quot;Male&quot;,&quot;Female&quot;, &quot;Female&quot;, &quot;Male&quot;) v3 &lt;- c(TRUE,FALSE,FALSE,TRUE) v4 &lt;- c() #一个不包含任何值的向量，输出为NULL 2.1.1.1.4 使用seq函数生成等差序列的向量 seq函数的原型是 seq(from=1,to=1,by=((to-from)/(length.out - 1)),length.out = NULL,along.with = NULL,...) 其中，from是首项，默认为1；to是末项，默认为1；by是步长或等差增量，可以为负数；length.out是向量的长度；along.with:用于指明该向量与另外一个向量的长度相同，along.with后应为另外一个向量的名字。 s1 &lt;- seq(1,10,2) #向量从1开始，最大不超过10，步长为2 s2 &lt;- seq(1,9,length.out = 5) #步长是根据(9 - 1)/(5-1)计算出来 s3 &lt;- seq(3,by=3,length.out=5) s4 &lt;- seq(by=3,along.with = s3) #未指定from项时，默认从1开始，长度与向量s3相同 2.1.1.1.5 使用rep函数创建重复序列的向量 rep函数可以将某一向量重复若干次，该函数的原型如下： rep(x , times = 1, length.out = NA, each = 1) 参数中，x为要重复的序列对象；times为重复的次数，默认为1；length.out为产生的向量长度，默认为NA（未限制）；each为每个元素重复的次数，默认为1。 r1 &lt;- rep(1:3,2) r2 &lt;- rep(1:3, each =2) r3 &lt;- rep(c(2,5),c(3,4)) #输出2 2 2 5 5 5 5 5将向量c(2, 5)按照后面给出的次数向量依次重复3次和4次 r4 &lt;- rep(c(2,4,6),each=2 ,length.out = 5) ## [1] 1 2 3 1 2 3 ## [1] 1 1 2 2 3 3 ## [1] 2 2 2 5 5 5 5 ## [1] 2 2 4 4 6 2.1.2 时间日期 日期时间值通常以字符串形式传入R 中，然后转化为以数值形式存储的日期时间变量。 R 的内部日期是以1970 年1 月1 日至今的天数来存储，内部时间则是以1970 年1 月1 日至今的 秒数来存储。 tidyverse 系列的lubridate 包提供了更加方便的函数，生成、转换、管理日期时间数据，足以代替R 自带的日期时间函数。 2.1.3 识别日期时间 library(lubridate) ## Loading required package: timechange ## ## Attaching package: &#39;lubridate&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## date, intersect, setdiff, union today() ## [1] &quot;2023-05-15&quot; now() ## [1] &quot;2023-05-15 10:54:15 CST&quot; as_datetime(today()) # 日期型转日期时间型 ## [1] &quot;2023-05-15 UTC&quot; as_date(now()) # 日期时间型转日期型 ## [1] &quot;2023-05-15&quot; 无论年月日/时分秒按什么顺序及以什么间隔符分隔，总能正确地识别成日期时间值： ymd(&quot;2020/03~01&quot;) ## [1] &quot;2020-03-01&quot; myd(&quot;03202001&quot;) ## [1] &quot;2020-03-01&quot; dmy(&quot;03012020&quot;) ## [1] &quot;2020-01-03&quot; ymd_hm(&quot;2020/03~011213&quot;) ## [1] &quot;2020-03-01 12:13:00 UTC&quot; 注：根据需要可以ymd_h/myd_hm/dmy_hms 任意组合；可以用参数tz =“…” 指定时区。 也可以用make_date() 和make_datetime() 从日期时间组件创建日期时间： make_date(2020, 8, 27) ## [1] &quot;2020-08-27&quot; make_datetime(2020, 8, 27, 21, 27, 15) ## [1] &quot;2020-08-27 21:27:15 UTC&quot; 2.2 控制结构 编程中的控制结构，是指分支结构和循环结构。 2.2.1 分支结构 正常程序结构与一步一步解决问题是一致的，即顺序结构，过程中可能需要对不同情形选择走不同的支路，即分支结构，是用条件语句做判断以实现分支： 图2.1: 分支结构 1.一个分支 if(条件) { 执行体 } 2.两个分支 if(条件) { 执行体1 } else { 执行体2 } 例如，实现计算|x|: if(x&lt;0) { y = -x } else { y = x } 3.多个分支 if(条件) { 执行体1 } else if(条件2) { 执行体2 } else { 执行体n } 例子：实现将百分制分数转化为五级制分数 if(score &gt;= 90) { res = &quot; 优&quot; } else if(score &gt;= 80) { res = &quot; 良&quot; } else if(score &gt;= 70) { res = &quot; 中&quot; } else if(score &gt;= 60) { res = &quot; 及格&quot; } else { res = &quot; 不及格&quot; } 另一种多分支的写法是用switch()，不推荐。一般用于自定义函数时，若需要根据参数不同指示值执行不同代码块，见：§2.4.1.1节。 函数ifelse() 可简化代码，仍以计算|x| 为例： ifelse(x &lt; 0, -x, x) 2.2.2 循环结构 图2.2: 循环结构 2.2.2.1 for循环 例子：计算iris前四列的均值 df = as_tibble(iris[,1:4]) output = vector(&quot;double&quot;, 4) # 1. 输出 for (i in 1:4) { # 2. 迭代器 output[i] = mean(df[[i]]) # 3. 循环体 } output ## [1] 5.843333 3.057333 3.758000 1.199333 for 循环有三个组件： 输出：output = vector(“double”, 4) 在循环开始之前，最好为输出分配足够的存储空间，这样效率更高：若每循环一次，就用c() 合并一次，效率会很低下。通常是用vector() 函数创建一个给定长度的空向量，它有两个参数：向量类型(logical, integer, double, character 等) 、向量长度。 迭代器：i in 1:4 确定怎么循环：每次for 循环将对i 赋一个1:4 中的值，可将i 理解为代词it. 有时候会用1:length(df), 但更安全的做法是用seq_along(df) ，它能保证即使不小心遇到长度为0 的向量时，仍能正确工作。 循环体：output[i] = mean(df[[i]]) 2.3 apply函数组 在 R 的基础包中有一类函数叫 apply, 包括 apply, lapply, sapply, vapply, mapply, replacate 等. 这些函数相同的地方都是接受一个 list, matrix 或者 data.frame 作为参数, 同时接受一个函数作为参数, 然后对数据的每一行或列都使用函数进行处理, 相当于 “把函数应用 (apply) 到每一个单元”. 2.3.1 apply apply 函数本身的运算速度其实和 for loop 很接近, 但是由于其语句少, 结构简单, 并且在能够调用 vapply 等高效的函数地方进行调用, 在进行大量重复应用相同函数到同一个数据集的时候效率似乎要比 for loop 要高一些. apply 函数有三个主要参数: 一个是data数据集,array, matrix, data.frame, list 都可以; 一个是 MARGIN, MARGIN 为 1 的时候对 matrix的每一行运行函数, MARGIN 为 2 的时候对 matrix 的每一列运行函数, 如果是 array 则可能是更高维; 一个是要对数据集运行的函数. apply(x, MARGIN, FUN, …) x：为数据对象(矩阵、多维数组、数据框) ； MARGIN：1 表示按行，2 表示按列； FUN：表示要作用的函数 x = matrix(1:6, ncol = 3) x ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 apply(x, 1, mean) # 按行求均值 ## [1] 3 4 apply(x, 2, mean) # 按列求均值 ## [1] 1.5 3.5 5.5 apply(df, 2, mean) # 对前文df 计算各列的均值 ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 5.843333 3.057333 3.758000 1.199333 2.3.2 lapply lapply() 函数是一个最基础循环操作函数，用来对vector、list、data.frame 逐元、逐成分、逐列分别应用函数FUN，并返回和x 长度相同的list 对象。其基本格式为： lapply(x, FUN, …) x：为数据对象(列表、数据框、向量) ； FUN：表示要作用的函数。 lapply(df, mean) # 对前文df 计算各列的均值 ## $Sepal.Length ## [1] 5.843333 ## ## $Sepal.Width ## [1] 3.057333 ## ## $Petal.Length ## [1] 3.758 ## ## $Petal.Width ## [1] 1.199333 2.3.3 sapply sapply() 函数是lapply() 的简化版本，多了一个参数simplify，若simplify=FALSE，则同lapply()，若为TRUE，则将输出的list 简化为向量或矩阵。其基本格式为： sapply(x, FUN, simplify = TRUE, …) sapply(df, mean) # 对前文df 计算各列的均值 ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 5.843333 3.057333 3.758000 1.199333 2.3.4 vapply sapply()会尝试对apply的结果进行简化，如果无法简化，则不进行简化，返回原始结果。与sapply()类似，vapply()也会对apply结果进行简化，vapply()的不同之处在于，它需要显式地指明所希望简化为的具体格式，如果无法简化为所指定的格式，则会给出Error。使用cls_vect &lt;- sapply(flags, class) 可以得到flags中各列的类型名称，并简化为一个character型的vector，使用vapply()并指明结果格式为character(1) 可以得到相同的结果： vapply(flags, class, character(1)) 而如果希望通过vapplu()得到numeric(1) 的结果，会出现Error： vapply(flags, class, numeric(1)) 2.4 自定义函数 例子：百分制数字对应五级制分数 先梳理一般代码段 score &lt;- 76 if (score &gt;= 90) { res &lt;- &quot; 优&quot; } else if (score &gt;= 80) { res &lt;- &quot; 良&quot; } else if (score &gt;= 70) { res &lt;- &quot; 中&quot; } else if (score &gt;= 60) { res &lt;- &quot; 及格&quot; } else { res &lt;- &quot; 不及格&quot; } res ## [1] &quot; 中&quot; 一般函数 Score_Conv &lt;- function(score) { if (score &gt;= 90) { res &lt;- &quot; 优&quot; } else if (score &gt;= 80) { res &lt;- &quot; 良&quot; } else if (score &gt;= 70) { res &lt;- &quot; 中&quot; } else if (score &gt;= 60) { res &lt;- &quot; 及格&quot; } else { res &lt;- &quot; 不及格&quot; } res } 向量化改进 法一：for循环 Score_Conv2 &lt;- function(score) { n &lt;- length(score) res &lt;- vector(&quot;character&quot;, n) for (i in 1:n) { if (score[i] &gt;= 90) { res[i] &lt;- &quot; 优&quot; } else if (score[i] &gt;= 80) { res[i] &lt;- &quot; 良&quot; } else if (score[i] &gt;= 70) { res[i] &lt;- &quot; 中&quot; } else if (score[i] &gt;= 60) { res[i] &lt;- &quot; 及格&quot; } else { res[i] &lt;- &quot; 不及格&quot; } } res } # 结果测试 score &lt;- seq(50, 100, 10) Score_Conv2(score = score) ## [1] &quot; 不及格&quot; &quot; 及格&quot; &quot; 中&quot; &quot; 良&quot; &quot; 优&quot; &quot; 优&quot; 法二：利用map 系列函数 score &lt;- c(25, 67, 100) purrr::map_chr(score, Score_Conv) ## [1] &quot; 不及格&quot; &quot; 及格&quot; &quot; 优&quot; 2.4.1 函数设置 2.4.1.1 设定默认参数 分别计算样本标准差和总体标准差。默认计算样本标准差。 MeanStd &lt;- function(x, type = &quot;sample&quot;) { mu &lt;- mean(x) n &lt;- length(x) switch(type, &quot;sample&quot; = { std &lt;- sqrt(sum((x - mu)^2) / (n - 1)) }, &quot;population&quot; = { std &lt;- sqrt(sum((x - mu)^2) / n) } ) list(mu = mu, std = std) } MeanStd(1:5) ## $mu ## [1] 3 ## ## $std ## [1] 1.581139 2.4.1.2 缺省参数 函数可输入无穷多个参数 dots_sum = function(...){ sum(...) } dots_sum(1,2,3,4,5) ## [1] 15 "],["数据操作.html", "3 数据操作 3.1 数据连接 3.2 数据操作 3.3 分组汇总 3.4 其他数据操作 3.5 整洁计算", " 3 数据操作 3.1 数据连接 3.1.1 合并行与和并列 合并行和和并列分别用dplyr 包中的bind_rows() 和bind_cols() 实现。 bind_rows( sample_n(iris,size = 2), sample_n(iris,size = 2), sample_n(iris,size = 2) ) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 6.6 2.9 4.6 1.3 versicolor ## 2 7.0 3.2 4.7 1.4 versicolor ## 3 7.7 3.0 6.1 2.3 virginica ## 4 6.5 2.8 4.6 1.5 versicolor ## 5 6.2 3.4 5.4 2.3 virginica ## 6 6.6 3.0 4.4 1.4 versicolor one=mtcars[1:4,1:3] two=mtcars[1:4,4:5] bind_cols(one,two) ## mpg cyl disp hp drat ## Mazda RX4 21.0 6 160 110 3.90 ## Mazda RX4 Wag 21.0 6 160 110 3.90 ## Datsun 710 22.8 4 108 93 3.85 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.1.2 根据值匹配合并数据框 3.1.3 实现R中实现stata的merge命令 A 小米 华为 苹果 A B 小米 1 小米 2 苹果 1 OPPO 1 A B merge_ 小米 1 匹配上 小米 2 匹配上 华为 NA 只在data1 苹果 1 匹配上 OPPO 1 只在data2 data1 &lt;- data.frame( A=c(&quot;小米&quot;,&quot;华为&quot;,&quot;苹果&quot;) ) data2 &lt;- data.frame( A=c(&quot;小米&quot;,&quot;小米&quot;,&quot;苹果&quot;,&quot;OPPO&quot;), B=c(&quot;1&quot;,&quot;2&quot;,&quot;1&quot;,&quot;1&quot;) ) data1 %&gt;% mutate(C=1) %&gt;% full_join(data2,by=&quot;A&quot;) %&gt;% mutate(merge_=case_when(is.na(C)~&quot;只在data2&quot;, is.na(B) ~&quot;只在data1&quot;, TRUE~&quot;匹配上&quot;)) %&gt;% select(-C) ## A B merge_ ## 1 小米 1 匹配上 ## 2 小米 2 匹配上 ## 3 华为 &lt;NA&gt; 只在data1 ## 4 苹果 1 匹配上 ## 5 OPPO 1 只在data2 3.2 数据操作 select()—— 选择列 filter()/slice()——筛选行 arrange()——对行排序 mutate()—— 修改列/创建新列 summarize()—— 汇总 相同之处是 这些函数都可以与group_by()——分组 第1 个参数是数据框，方便管道操作 根据列名访问数据框的列，且列名不用加引号 返回结果是一个新数据框，不改变原数据框 3.2.1 选择列（select） 数据 df = readxl::read_xlsx(&quot;datas/ExamDatas_NAs.xlsx&quot;) df ## # A tibble: 50 × 8 ## class name sex chinese math english moral science ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 六1班 何娜 女 87 92 79 9 10 ## 2 六1班 黄才菊 女 95 77 75 NA 9 ## 3 六1班 陈芳妹 女 79 87 66 9 10 ## 4 六1班 陈学勤 男 NA 79 66 9 10 ## 5 六1班 陈祝贞 女 76 79 67 8 10 ## 6 六1班 何小薇 女 83 73 65 8 9 ## 7 六1班 雷旺 男 NA 80 68 8 9 ## 8 六1班 陈欣越 男 57 80 60 9 9 ## 9 六1班 黄亦婷 女 77 NA 54 8 10 ## 10 六1班 陈媚 女 68 55 66 8 9 ## # … with 40 more rows 3.2.2 选择列语法 （1）用列名或索引选择列 df %&gt;% select(name,sex,math) # 或者select(2, 3, 5) ## # A tibble: 50 × 3 ## name sex math ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 何娜 女 92 ## 2 黄才菊 女 77 ## 3 陈芳妹 女 87 ## 4 陈学勤 男 79 ## 5 陈祝贞 女 79 ## 6 何小薇 女 73 ## 7 雷旺 男 80 ## 8 陈欣越 男 80 ## 9 黄亦婷 女 NA ## 10 陈媚 女 55 ## # … with 40 more rows (2) 借助运算符选择列 用: 选择连续的若干列 用! 选择变量集合的余集（反选） &amp; 和| 选择变量集合的交或并 c() 合并多个选 (3) 借助选择助手函数 选择指定列： everything(): 选择所有列 last_col(): 选择最后一列，可以带参数，如last_col(5) 选择倒数第6 列 选择列名匹配的列： starts_with(): 以某前缀开头的列名 ends_with(): 以某后缀结尾的列名 contains(): 包含某字符串的列名 matches(): 匹配正则表达式的列名 num_range(): 匹配数值范围的列名，如num_range(“x”, 1:3) 匹配x1, x2, x3 结合函数选择列： where(): 应用一个函数到所有列，选择返回结果为TRUE 的列，比如与is.numeric 等函数连用。 3.2.3 选择列的例子 df %&gt;% select(starts_with(&quot;m&quot;)) ## # A tibble: 50 × 2 ## math moral ## &lt;dbl&gt; &lt;dbl&gt; ## 1 92 9 ## 2 77 NA ## 3 87 9 ## 4 79 9 ## 5 79 8 ## 6 73 8 ## 7 80 8 ## 8 80 9 ## 9 NA 8 ## 10 55 8 ## # … with 40 more rows df %&gt;% select(ends_with(&quot;e&quot;)) ## # A tibble: 50 × 3 ## name chinese science ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 何娜 87 10 ## 2 黄才菊 95 9 ## 3 陈芳妹 79 10 ## 4 陈学勤 NA 10 ## 5 陈祝贞 76 10 ## 6 何小薇 83 9 ## 7 雷旺 NA 9 ## 8 陈欣越 57 9 ## 9 黄亦婷 77 10 ## 10 陈媚 68 9 ## # … with 40 more rows df %&gt;% select(contains(&quot;a&quot;)) ## # A tibble: 50 × 4 ## class name math moral ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 六1班 何娜 92 9 ## 2 六1班 黄才菊 77 NA ## 3 六1班 陈芳妹 87 9 ## 4 六1班 陈学勤 79 9 ## 5 六1班 陈祝贞 79 8 ## 6 六1班 何小薇 73 8 ## 7 六1班 雷旺 80 8 ## 8 六1班 陈欣越 80 9 ## 9 六1班 黄亦婷 NA 8 ## 10 六1班 陈媚 55 8 ## # … with 40 more rows 根据条件（逻辑判断）选择列，例如选择所有数值型的列： library(tidyselect) df %&gt;% select(where(is.numeric)) ## # A tibble: 50 × 5 ## chinese math english moral science ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 87 92 79 9 10 ## 2 95 77 75 NA 9 ## 3 79 87 66 9 10 ## 4 NA 79 66 9 10 ## 5 76 79 67 8 10 ## 6 83 73 65 8 9 ## 7 NA 80 68 8 9 ## 8 57 80 60 9 9 ## 9 77 NA 54 8 10 ## 10 68 55 66 8 9 ## # … with 40 more rows 也可以自定义返回TRUE 或FALSE 的判断函数，支持purrr 风格公式写法。例如，选择列和&gt;3000 的列： df[,4:8]%&gt;% select(where(~sum(.x,na.rm = TRUE)&gt;3000)) ## # A tibble: 50 × 2 ## chinese math ## &lt;dbl&gt; &lt;dbl&gt; ## 1 87 92 ## 2 95 77 ## 3 79 87 ## 4 NA 79 ## 5 76 79 ## 6 83 73 ## 7 NA 80 ## 8 57 80 ## 9 77 NA ## 10 68 55 ## # … with 40 more rows 结合n_distinct() 选择唯一值数目&lt; 10 的列： df %&gt;% select(where(~n_distinct(.x)&lt;10)) ## # A tibble: 50 × 4 ## class sex moral science ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 六1班 女 9 10 ## 2 六1班 女 NA 9 ## 3 六1班 女 9 10 ## 4 六1班 男 9 10 ## 5 六1班 女 8 10 ## 6 六1班 女 8 9 ## 7 六1班 男 8 9 ## 8 六1班 男 9 9 ## 9 六1班 女 8 10 ## 10 六1班 女 8 9 ## # … with 40 more rows 3.2.4 用“-” 删除列 df %&gt;% select(-c(name,chinese,science)) #select(-ends_with(&quot;e&quot;)) ## # A tibble: 50 × 5 ## class sex math english moral ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 六1班 女 92 79 9 ## 2 六1班 女 77 75 NA ## 3 六1班 女 87 66 9 ## 4 六1班 男 79 66 9 ## 5 六1班 女 79 67 8 ## 6 六1班 女 73 65 8 ## 7 六1班 男 80 68 8 ## 8 六1班 男 80 60 9 ## 9 六1班 女 NA 54 8 ## 10 六1班 女 55 66 8 ## # … with 40 more rows 选择math和除了“e”结尾的其他列 df %&gt;% select(math,everything(),-ends_with(&quot;e&quot;)) ## # A tibble: 50 × 5 ## math class sex english moral ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 92 六1班 女 79 9 ## 2 77 六1班 女 75 NA ## 3 87 六1班 女 66 9 ## 4 79 六1班 男 66 9 ## 5 79 六1班 女 67 8 ## 6 73 六1班 女 65 8 ## 7 80 六1班 男 68 8 ## 8 80 六1班 男 60 9 ## 9 NA 六1班 女 54 8 ## 10 55 六1班 女 66 8 ## # … with 40 more rows 注意： -ends_with() 要放在everything() 后面，否则删除的列就全回来了。 3.2.5 调整列的顺序 （1）列是根据被选择的顺序排列： df %&gt;% select(ends_with(&quot;e&quot;), math, name, class, sex) ## # A tibble: 50 × 6 ## name chinese science math class sex ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 何娜 87 10 92 六1班 女 ## 2 黄才菊 95 9 77 六1班 女 ## 3 陈芳妹 79 10 87 六1班 女 ## 4 陈学勤 NA 10 79 六1班 男 ## 5 陈祝贞 76 10 79 六1班 女 ## 6 何小薇 83 9 73 六1班 女 ## 7 雷旺 NA 9 80 六1班 男 ## 8 陈欣越 57 9 80 六1班 男 ## 9 黄亦婷 77 10 NA 六1班 女 ## 10 陈媚 68 9 55 六1班 女 ## # … with 40 more rows （2）将数值列移到name 列的后面： df %&gt;% select(math,everything()) ## # A tibble: 50 × 8 ## math class name sex chinese english moral science ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 92 六1班 何娜 女 87 79 9 10 ## 2 77 六1班 黄才菊 女 95 75 NA 9 ## 3 87 六1班 陈芳妹 女 79 66 9 10 ## 4 79 六1班 陈学勤 男 NA 66 9 10 ## 5 79 六1班 陈祝贞 女 76 67 8 10 ## 6 73 六1班 何小薇 女 83 65 8 9 ## 7 80 六1班 雷旺 男 NA 68 8 9 ## 8 80 六1班 陈欣越 男 57 60 9 9 ## 9 NA 六1班 黄亦婷 女 77 54 8 10 ## 10 55 六1班 陈媚 女 68 66 8 9 ## # … with 40 more rows everything() 返回未被选择的所有列，将某一列移到第一列时很方便： （3）将选择的列移到某列之前或之后 df %&gt;% relocate(where(is.numeric),.after = name) ## # A tibble: 50 × 8 ## class name chinese math english moral science sex ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 六1班 何娜 87 92 79 9 10 女 ## 2 六1班 黄才菊 95 77 75 NA 9 女 ## 3 六1班 陈芳妹 79 87 66 9 10 女 ## 4 六1班 陈学勤 NA 79 66 9 10 男 ## 5 六1班 陈祝贞 76 79 67 8 10 女 ## 6 六1班 何小薇 83 73 65 8 9 女 ## 7 六1班 雷旺 NA 80 68 8 9 男 ## 8 六1班 陈欣越 57 80 60 9 9 男 ## 9 六1班 黄亦婷 77 NA 54 8 10 女 ## 10 六1班 陈媚 68 55 66 8 9 女 ## # … with 40 more rows 3.2.6 重命名列 （1）为所有列设置新列名set_names() df %&gt;% set_names(&quot; 班级&quot;, &quot; 姓名&quot;, &quot; 性别&quot;, &quot; 语文&quot;, &quot; 数学&quot;, &quot; 英语&quot;, &quot; 品德&quot;, &quot; 科学&quot;) ## # A tibble: 50 × 8 ## ` 班级` ` 姓名` ` 性别` ` 语文` ` 数学` ` 英语` ` 品德` ` 科学` ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 六1班 何娜 女 87 92 79 9 10 ## 2 六1班 黄才菊 女 95 77 75 NA 9 ## 3 六1班 陈芳妹 女 79 87 66 9 10 ## 4 六1班 陈学勤 男 NA 79 66 9 10 ## 5 六1班 陈祝贞 女 76 79 67 8 10 ## 6 六1班 何小薇 女 83 73 65 8 9 ## 7 六1班 雷旺 男 NA 80 68 8 9 ## 8 六1班 陈欣越 男 57 80 60 9 9 ## 9 六1班 黄亦婷 女 77 NA 54 8 10 ## 10 六1班 陈媚 女 68 55 66 8 9 ## # … with 40 more rows （2）只修改部分列名rename()，格式为：新名= 旧名 df %&gt;% rename(数学=math,科学=science) ## # A tibble: 50 × 8 ## class name sex chinese 数学 english moral 科学 ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 六1班 何娜 女 87 92 79 9 10 ## 2 六1班 黄才菊 女 95 77 75 NA 9 ## 3 六1班 陈芳妹 女 79 87 66 9 10 ## 4 六1班 陈学勤 男 NA 79 66 9 10 ## 5 六1班 陈祝贞 女 76 79 67 8 10 ## 6 六1班 何小薇 女 83 73 65 8 9 ## 7 六1班 雷旺 男 NA 80 68 8 9 ## 8 六1班 陈欣越 男 57 80 60 9 9 ## 9 六1班 黄亦婷 女 77 NA 54 8 10 ## 10 六1班 陈媚 女 68 55 66 8 9 ## # … with 40 more rows （3） rename_with(.data, .fn, .cols)函数 参数.col 支持用选择列语法选择要重命名的 列，.fn 是对所选列重命名的函数，将原列名的字符向量变成新列名的字符向量。比如，将包含”m’’ 的列名，都拼接上前缀”new_“: 3.3 分组汇总 3.3.1 创建分组 用group_by() 创建分组，只是对数据框增加了分组信息（用group_keys() 查看），并不是真的将数据分割为多个数据框。 df_grp = iris %&gt;% group_by(Species) group_keys(df_grp) # 分组键值(唯一识别分组) ## # A tibble: 3 × 1 ## Species ## &lt;fct&gt; ## 1 setosa ## 2 versicolor ## 3 virginica group_indices(df_grp) # 查看每一行属于哪一分组 ## [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ## [38] 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 ## [75] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 ## [112] 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 ## [149] 3 3 group_rows(df_grp) # 查看每一组包含哪些行 ## &lt;list_of&lt;integer&gt;[3]&gt; ## [[1]] ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ## [26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 ## ## [[2]] ## [1] 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 ## [20] 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 ## [39] 89 90 91 92 93 94 95 96 97 98 99 100 ## ## [[3]] ## [1] 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 ## [20] 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 ## [39] 139 140 141 142 143 144 145 146 147 148 149 150 ungroup(df_grp) # 解除分组 3.3.2 分组汇总 对数据框做分组最主要的目的就是做分组汇总，汇总就是以某种方式组合行，用dplyr 包中的summarise() 函数实现，结果只保留分组列唯一值和新创建的汇总列。 (1) summarise() 可以与很多自带或自定义的汇总函数连用，常用的汇总函数有： n(): 观测数 n_distinct(var): 变量var 的唯一值数目 sum(var), max(var), min(var), . . . mean(var), median(var), sd(var), IQR(var), df = readxl::read_xlsx(&quot;datas/ExamDatas_NAs.xlsx&quot;) df %&gt;% group_by(sex) %&gt;% summarise(n=n(), math_avg=mean(math,na.rm=TRUE), math_med=median(math)) ## # A tibble: 3 × 4 ## sex n math_avg math_med ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 男 24 64.6 NA ## 2 女 25 70.8 NA ## 3 &lt;NA&gt; 1 85 85 （2）对所有列汇总 df %&gt;% select(-name) %&gt;% group_by(class, sex) %&gt;% summarise(across(everything(),mean,na.rm=TRUE)) ## # A tibble: 12 × 7 ## # Groups: class [6] ## class sex chinese math english moral science ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 六1班 男 57 79.7 64.7 8.67 9.33 ## 2 六1班 女 80.7 77.2 67.4 8.33 9.57 ## 3 六2班 男 75.4 68.8 42.6 8.8 9.25 ## 4 六2班 女 92.2 73.8 63.8 8.33 9 ## 5 六3班 男 66 30.4 67.6 4.6 4.75 ## 6 六3班 女 68.4 49.2 67.8 6.25 7.2 ## 7 六4班 男 84.8 79.2 55.7 8.6 8.5 ## 8 六4班 女 85.2 74 63.7 8.75 7.75 ## 9 六5班 男 66.5 64.5 65.3 8.25 8.25 ## 10 六5班 女 80.4 75.4 63.4 8.75 8.25 ## 11 六5班 &lt;NA&gt; 58 85 48 9 10 ## 12 &lt;NA&gt; 男 90 86 72 9 10 （3）对某些列汇总 计算列名中包含”h”的列的平均值 df %&gt;% group_by(class, sex) %&gt;% summarise(across(contains(&quot;h&quot;), mean, na.rm = TRUE)) ## `summarise()` has grouped output by &#39;class&#39;. You can override using the ## `.groups` argument. ## # A tibble: 12 × 5 ## # Groups: class [6] ## class sex chinese math english ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 六1班 男 57 79.7 64.7 ## 2 六1班 女 80.7 77.2 67.4 ## 3 六2班 男 75.4 68.8 42.6 ## 4 六2班 女 92.2 73.8 63.8 ## 5 六3班 男 66 30.4 67.6 ## 6 六3班 女 68.4 49.2 67.8 ## 7 六4班 男 84.8 79.2 55.7 ## 8 六4班 女 85.2 74 63.7 ## 9 六5班 男 66.5 64.5 65.3 ## 10 六5班 女 80.4 75.4 63.4 ## 11 六5班 &lt;NA&gt; 58 85 48 ## 12 &lt;NA&gt; 男 90 86 72 (4) 对满足条件的列做多种汇总 分别计算数值型各列的平均值和sum library(tidyselect) df %&gt;% group_by(class) %&gt;% summarise(across(.cols = where(is.numeric), .fns = list(sum=sum,mean=mean),na.rm=TRUE)) ## # A tibble: 6 × 11 ## class chines…¹ chine…² math_…³ math_…⁴ engli…⁵ engli…⁶ moral…⁷ moral…⁸ scien…⁹ ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 六1班 622 77.8 702 78 666 66.6 76 8.44 95 ## 2 六2班 746 82.9 570 71.2 468 52 69 8.62 73 ## 3 六3班 606 67.3 349 38.8 609 67.7 48 5.33 55 ## 4 六4班 850 85 771 77.1 525 58.3 78 8.67 82 ## 5 六5班 726 72.6 720 72 561 62.3 77 8.56 76 ## 6 &lt;NA&gt; 90 90 86 86 72 72 9 9 10 ## # … with 1 more variable: science_mean &lt;dbl&gt;, and abbreviated variable names ## # ¹​chinese_sum, ²​chinese_mean, ³​math_sum, ⁴​math_mean, ⁵​english_sum, ## # ⁶​english_mean, ⁷​moral_sum, ⁸​moral_mean, ⁹​science_sum 分组计数 用count() 按分类变量class 和sex 分组，并按分组大小排序： df %&gt;% count(class,sex,sort = TRUE) ## # A tibble: 12 × 3 ## class sex n ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 六1班 女 7 ## 2 六4班 男 6 ## 3 六2班 男 5 ## 4 六3班 男 5 ## 5 六3班 女 5 ## 6 六5班 女 5 ## 7 六2班 女 4 ## 8 六4班 女 4 ## 9 六5班 男 4 ## 10 六1班 男 3 ## 11 六5班 &lt;NA&gt; 1 ## 12 &lt;NA&gt; 男 1 对已分组的数据框，用tally() 计数 df %&gt;% group_by(math_level = cut(math, breaks = c(0, 60, 75, 80, 100), right = FALSE)) %&gt;% tally() ## # A tibble: 5 × 2 ## math_level n ## &lt;fct&gt; &lt;int&gt; ## 1 [0,60) 14 ## 2 [60,75) 11 ## 3 [75,80) 5 ## 4 [80,100) 17 ## 5 &lt;NA&gt; 3 注：count() 和tally() 都有参数wt 设置加权计数。 用add_count() 和add_tally() 可为数据集增加一列按分组变量分组的计数： df %&gt;% add_count(class,sex) ## # A tibble: 50 × 9 ## class name sex chinese math english moral science n ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 六1班 何娜 女 87 92 79 9 10 7 ## 2 六1班 黄才菊 女 95 77 75 NA 9 7 ## 3 六1班 陈芳妹 女 79 87 66 9 10 7 ## 4 六1班 陈学勤 男 NA 79 66 9 10 3 ## 5 六1班 陈祝贞 女 76 79 67 8 10 7 ## 6 六1班 何小薇 女 83 73 65 8 9 7 ## 7 六1班 雷旺 男 NA 80 68 8 9 3 ## 8 六1班 陈欣越 男 57 80 60 9 9 3 ## 9 六1班 黄亦婷 女 77 NA 54 8 10 7 ## 10 六1班 陈媚 女 68 55 66 8 9 7 ## # … with 40 more rows 3.3.3 自己的例子 表3.1: 数据形式 x y A 1 A 2 A 1 B 1 B 1 C 3 df %&gt;% group_by(x) %&gt;% summarise(n=sum(y)) ## # A tibble: 3 × 2 ## x n ## &lt;chr&gt; &lt;dbl&gt; ## 1 A 4 ## 2 B 2 ## 3 C 3 3.4 其他数据操作 3.4.1 按行汇总 通常的数据操作逻辑都是按列方式(colwise)，这使得按行汇总很困难。 dplyr 包提供了rowwise() 函数为数据框创建按行方式(rowwise)，使用rowwise() 后并不是真的 改变数据框，只是创建了按行元信息，改变了数据框的操作逻辑： 按行汇总语数外的总分 df = readxl::read_xlsx(&quot;datas/ExamDatas_NAs.xlsx&quot;) rf = df %&gt;% rowwise() rf %&gt;% mutate(total=sum(c(chinese,math,english))) ## # A tibble: 50 × 9 ## # Rowwise: ## class name sex chinese math english moral science total ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 六1班 何娜 女 87 92 79 9 10 258 ## 2 六1班 黄才菊 女 95 77 75 NA 9 247 ## 3 六1班 陈芳妹 女 79 87 66 9 10 232 ## 4 六1班 陈学勤 男 NA 79 66 9 10 NA ## 5 六1班 陈祝贞 女 76 79 67 8 10 222 ## 6 六1班 何小薇 女 83 73 65 8 9 221 ## 7 六1班 雷旺 男 NA 80 68 8 9 NA ## 8 六1班 陈欣越 男 57 80 60 9 9 197 ## 9 六1班 黄亦婷 女 77 NA 54 8 10 NA ## 10 六1班 陈媚 女 68 55 66 8 9 189 ## # … with 40 more rows 函数c_across() 是为按行方式(rowwise) 在选定的列范围汇总数据而设计的，它没有提供.fns 参数，只能选择列 rf %&gt;% mutate(total = sum(c_across(where(is.numeric)))) ## # A tibble: 50 × 9 ## # Rowwise: ## class name sex chinese math english moral science total ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 六1班 何娜 女 87 92 79 9 10 277 ## 2 六1班 黄才菊 女 95 77 75 NA 9 NA ## 3 六1班 陈芳妹 女 79 87 66 9 10 251 ## 4 六1班 陈学勤 男 NA 79 66 9 10 NA ## 5 六1班 陈祝贞 女 76 79 67 8 10 240 ## 6 六1班 何小薇 女 83 73 65 8 9 238 ## 7 六1班 雷旺 男 NA 80 68 8 9 NA ## 8 六1班 陈欣越 男 57 80 60 9 9 215 ## 9 六1班 黄亦婷 女 77 NA 54 8 10 NA ## 10 六1班 陈媚 女 68 55 66 8 9 206 ## # … with 40 more rows 若只是做按行求和或均值，直接用rowSums() / rowMeans() 速度更快（不需要分割-汇总-合并）， 这里的rowwise 行化后提供可以做更多的按行汇总的可能。 df %&gt;% mutate(total = rowSums(across(where(is.numeric)))) ## # A tibble: 50 × 9 ## class name sex chinese math english moral science total ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 六1班 何娜 女 87 92 79 9 10 277 ## 2 六1班 黄才菊 女 95 77 75 NA 9 NA ## 3 六1班 陈芳妹 女 79 87 66 9 10 251 ## 4 六1班 陈学勤 男 NA 79 66 9 10 NA ## 5 六1班 陈祝贞 女 76 79 67 8 10 240 ## 6 六1班 何小薇 女 83 73 65 8 9 238 ## 7 六1班 雷旺 男 NA 80 68 8 9 NA ## 8 六1班 陈欣越 男 57 80 60 9 9 215 ## 9 六1班 黄亦婷 女 77 NA 54 8 10 NA ## 10 六1班 陈媚 女 68 55 66 8 9 206 ## # … with 40 more rows 按行方式(rowwise) 可以理解为一种特殊的分组：每一行作为一组。为rowwise() 提供行ID，用 summarise() 做汇总更能体会这一点。要解除行化模式，用ungroup(). df %&gt;% rowwise(name) %&gt;% summarise(total=c_across(where(is.numeric))) ## `summarise()` has grouped output by &#39;name&#39;. You can override using the ## `.groups` argument. ## # A tibble: 250 × 2 ## # Groups: name [50] ## name total ## &lt;chr&gt; &lt;dbl&gt; ## 1 何娜 87 ## 2 何娜 92 ## 3 何娜 79 ## 4 何娜 9 ## 5 何娜 10 ## 6 黄才菊 95 ## 7 黄才菊 77 ## 8 黄才菊 75 ## 9 黄才菊 NA ## 10 黄才菊 9 ## # … with 240 more rows rowwise 行化操作的缺点是速度相对更慢，更建议用XXX 节讲到的pmap() 逐行迭代。 3.4.2 窗口函数 汇总函数如sum() 和mean() 接受n 个输入，返回1 个值。而窗口函数是汇总函数的变体：接受n 个输入，返回n 个值。 例如，cumsum()、cummean()、rank()、lead()、lag() 等。 （1）排名和排序函数 从小到大排名（ties.method=“min”)，若要从大到小排名需要套一个desc() 安装数学成绩给每个学生生存排名 df %&gt;% mutate(ranks = min_rank(desc(math))) %&gt;% arrange(ranks) ## # A tibble: 50 × 9 ## class name sex chinese math english moral science ranks ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 六4班 周婵 女 92 94 77 10 9 1 ## 2 六4班 陈丽丽 女 87 93 NA 8 6 2 ## 3 六1班 何娜 女 87 92 79 9 10 3 ## 4 六5班 符苡榕 女 85 89 76 9 NA 4 ## 5 六2班 黄祖娜 女 94 88 75 10 10 5 ## 6 六1班 陈芳妹 女 79 87 66 9 10 6 ## 7 六4班 李小龄 男 90 87 69 10 10 6 ## 8 六2班 徐雅琦 女 92 86 72 NA 9 8 ## 9 &lt;NA&gt; 徐达政 男 90 86 72 9 10 8 ## 10 六4班 杨昌晟 男 84 85 64 8 10 10 ## # … with 40 more rows 3.5 整洁计算 tidyverse 代码之所以这么“整洁、优雅”，访问列只需要提供列名，不需要加引号，不需要加数据框环境df$, 这是因为它内部采用了一套整洁计算（tidy evaluation）框架。 如果我们也想自定义这样的“整洁、优雅”函数，即在自定义函数中页这样“整洁、优雅”地传递参数，就需要掌握一点整洁计算的技术。 3.5.1 数据屏蔽与整洁选择 整洁计算的两种基本形式是 数据屏蔽：使得可以不用带数据框（环境变量）名字，就能使用数据框内的变量（数据变量），便于在数据集内计算值 整洁选择：即各种选择列语法，便于使用数据集中的列 数据屏蔽为直接使用带来了代码简洁，但作为函数参数时的间接使用，正常是环境变量，要想作为数据变量使用，则需要用两个大括号括起来{{var}}： var_summary = function(data, var) { data %&gt;% summarise(n = n(), mean = mean({{var}})) } mtcars %&gt;% group_by(cyl) %&gt;% var_summary(mpg) ## # A tibble: 3 × 3 ## cyl n mean ## &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 4 11 26.7 ## 2 6 7 19.7 ## 3 8 14 15.1 若是字符向量形式，想作为数据变量，则需要在函数体中使用.data[[var]]，这里.data 是代替数据集的代词： var_summary = function(data,var){ data %&gt;% summarise(n=n(),mean=mean(.data[[var]])) } mtcars %&gt;% group_by(cyl) %&gt;% var_summary(&quot;mpg&quot;) ## # A tibble: 3 × 3 ## cyl n mean ## &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 4 11 26.7 ## 2 6 7 19.7 ## 3 8 14 15.1 "],["可视化与建模.html", "4 可视化与建模 4.1 ggplot2基础语法 4.2 自定义ggplot2函数 4.3 散点图 4.4 箱线图 4.5 生存分析 4.6 Plotly", " 4 可视化与建模 4.1 ggplot2基础语法 4.1.1 ggplot2概述 ggplot是最流行的R可视化包，基于图层化语图形是一层一层的图层叠加而成，先进的绘图理念、优雅的语法代码、美观大方的生成图形，让ggplot2 迅速走红。 ggplot2 绘图语法 选取整洁数据将其映射为几何对象(如点、线等)，几何对象具有美学特征(如坐标轴、颜色等) ，若需要则对数据做统计变换，调整标度，将结果投影到坐标系，再根据喜好选择主题。 图4.1: ggplot2 绘图流程 ggplot 的语法包括10 个部件： 数据（data） 映射（mapping） 几何对象（grom） 标度（scale） 统计变换（stats） 坐标系（coord） 位置调整（position adjustments） 分面（facet） 主题（theme） 输出（output） 10 个部件中，前3 个是必须的，其他部件ggplot2 会自动帮你做好它认为’’ 最优’’ 的配置，当然也都可以手动定制。 ggplot(data = &lt;DATA&gt;, mapping = aes(&lt;MAPPINGS&gt;)) + &lt;GEOM_FUNCTION&gt;( mapping = aes(&lt;MAPPINGS&gt;), stat = &lt;STAT&gt;, position = &lt;POSITION&gt;) + &lt;SCALE_FUNCTION&gt; + &lt;COORDINATE_FUNCTION&gt; + &lt;FACET_FUNCTION&gt; + &lt;THEME_FUNCTION&gt; 4.1.2 数据、映射、几何对象 数据(data) 数据：用于绘图的数据，需要是整洁的数据框。本节用ggplot2 自带数据集演示。 library(tidyverse) head(mpg, 4) ## # A tibble: 4 × 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p compa… ## 2 audi a4 1.8 1999 4 manual(m5) f 21 29 p compa… ## 3 audi a4 2 2008 4 manual(m6) f 20 31 p compa… ## 4 audi a4 2 2008 4 auto(av) f 21 30 p compa… 用ggplot() 创建一个坐标系统，先只提供数据，此时只是创建了一个空的图形： ggplot(data = mpg) 映射(mapping) 函数aes() 是ggplot2 中的映射函数, 所谓映射就是将数据集中的变量数据映射(关联) 到相应的图形属性，也称为“美学映射”或“美学”。 最常用的映射(美学) 有： x：x轴 y：y轴 color：颜色 fill：填充 size：大小 shape：形状 alpha：透明度 最需要的美学是x 和y, 分别映射到变量displ 和hwy, 再将美学color 映射到drv，此时图形就有 了坐标轴和网格线，color 美学在绘制几何对象前还体现不出来： ggplot(data = mpg,mapping = aes(x = displ,y = hwy,color = drv)) 注意：映射不是直接为出现在图形中的颜色、外形、线型等设定特定值，而是建立数据中的变量 与可见的图形元素之间的联系，经常将图形的美学color, size 等映射到数据集的分类变量，以实现 不同分组用不同的美学来区分。所以，若要为美学指定特定值，比如color = “red”, 是不能放在映射aes() 中的。 几何对象(Geometric) 每个图形都是采用不同的视觉对象来表达数据，称为是‘‘几何对象’’。 通常用不同类型的“几何对象” 从不同角度来表达数据，如散点图、平滑曲线、线形图、条形图、 箱线图等。 ggplot2 提供了50 余种“几何对象”，均以geom_xxxx() 的方式命名，常用的有： geom_point()：散点图 geom_line()：折线图 geom_smooth()：光滑（拟合）曲线 geom_bar()/geom_col()：条形图 geom_histogram()：直方图 geom_density()：概率密度图 geom_boxplot()：箱线图 geom_abline()：参考直线 要绘制几何对象，就是添加图层即可。 ggplot(data = mpg,mapping = aes(x = displ,y = hwy,color = drv))+ geom_point() 不同的几何对象支持的美学会有些不同，美学映射也可以放在几何对象中，上面代码可改写为： ggplot(data = mpg,mapping = aes(x = displ,y = hwy))+ geom_point(aes(color= drv)) 前面提到，为图形美学设置特定值也是可以的，但不能放在映射aes() 中： ggplot(data = mpg,mapping = aes(x = displ,y = hwy))+ geom_point(color= &quot;blue&quot;) 图层是可以依次叠加的，再添加一个几何对象：光滑曲线，然后来区分一下如下两个图形： ggplot(mpg,aes(displ,hwy,color=drv))+ geom_point()+ geom_smooth() ## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; ggplot(mpg,aes(displ,hwy))+ geom_point(aes(color=drv))+ geom_smooth() ## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; 为什么会出现这种不同呢？这就涉及ggplot2“全局”与“局部”的约定： ggplot() 中的数据和映射，是全局的，可供所有几何对象共用； 而位于“几何对象”中的数据和映射，是局部的，只供该几何对象使用； “几何对象”优先使用局部的，局部没有则用全局的。 4.1.3 标度 通常ggplot2 会自动根据输入变量选择最优的坐标刻度方案，若要手动设置或调整，就需要用到标度函数：scale__(). 标度函数控制几何对象中的标度映射：不只是x, y 轴，还有color, fill, shape, size 产生的图例。它们是数据中的连续或分类变量的可视化表示，这需要关联到标度，所以要用到映射。 常用的标度函数有： scale_*_continunos()：*为x或y scale_*_discrete()：*为x或y scale_x_date() scale_x_datetime() scale_log10()，scale_sqrt(),scale_*_reverse()：*为x或y scalse_gradient()，scale_gradient2()，*为color，fill等 scales 包提供了很多现成的设置刻度标签风格的函数。 图4.2: 图例与坐标轴的组件 4.1.3.1 修改坐标轴刻度及刻度标签 用scale_*_continuous() 修改连续变量坐标轴的刻度和标签： 参数breaks 设置各个刻度的位置 参数labels 设置各个刻度对应的标签 ggplot(mpg,aes(displ,hwy))+ geom_point()+ scale_y_continuous(breaks = seq(15,40,by=10), labels = c(&quot;一五&quot;,&quot;二五&quot;,&quot;三五&quot;)) 用scale_*_discrete() 修改离散变量坐标轴的标签： ggplot(mpg,aes(x = drv))+ geom_bar() + #条形图 scale_x_discrete(labels=c(&quot;4&quot;=&quot;四驱&quot;,&quot;f&quot;=&quot;前驱&quot;,&quot;r&quot;=&quot;后驱&quot;)) 用scale_x_date() 设置日期刻度，参数date_breaks 设置刻度间隔，date_labels 设置标签的日期格式；借助scales包中的函数设置特殊格式，比如百分数(percent)、科学计数法(scientific)、美元格式(dollar) 等。 economics ## # A tibble: 574 × 6 ## date pce pop psavert uempmed unemploy ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1967-07-01 507. 198712 12.6 4.5 2944 ## 2 1967-08-01 510. 198911 12.6 4.7 2945 ## 3 1967-09-01 516. 199113 11.9 4.6 2958 ## 4 1967-10-01 512. 199311 12.9 4.9 3143 ## 5 1967-11-01 517. 199498 12.8 4.7 3066 ## 6 1967-12-01 525. 199657 11.8 4.8 3018 ## 7 1968-01-01 531. 199808 11.7 5.1 2878 ## 8 1968-02-01 534. 199920 12.3 4.5 3001 ## 9 1968-03-01 544. 200056 11.7 4.1 2877 ## 10 1968-04-01 544 200208 12.3 4.6 2709 ## # … with 564 more rows ggplot(tail(economics,45),aes(date,uempmed/100))+ geom_line()+ scale_x_date(date_breaks = &quot;6 months&quot;,date_labels = &quot;%b%Y&quot;)+ scale_y_continuous(labels = scales::percent) 4.1.3.2 修改坐标轴标签、图例名及图例位置 用labs() 函数的参数x, y, 或者函数xlab(), ylab(), 设置x 轴、y 轴标签，前面已使用color美学，则可以在labs() 函数中使用参数color 修改颜色的图例名。 图例位置是在theme 图层通过参数legend.position 设置，可选取值有“none”，“left”，“right”， “bottom”， “top”。 ggplot(mpg,aes(displ,hwy))+ geom_point(aes(color=drv))+ labs(x=&quot;引擎大小（L）&quot;,y=&quot;高速燃油率（mpg）&quot;,color=&quot;驱动类型&quot;) + #xlab(&quot;引擎大小（L）&quot;)+ylab(&quot;高速燃油率（mpg）&quot;) theme(legend.position = &quot;top&quot;) 4.1.3.3 设置坐标轴范围 用coord_cartesian() 函数的参数xlim 和ylim, 或者用xlim(), ylim() 函数，设置x 轴和y 轴的范围 ggplot(mpg,aes(displ,hwy))+ geom_point(aes(color=drv))+ coord_cartesian(xlim = c(5,7),ylim = c(10,30))#或+xlim(5,7)+ylim(10,30) 4.1.3.4 变换坐标轴 变换数据再绘图，比如对数变换，坐标刻度也会变成变换之后的，这使得图形不好理解。 ggplot2 提供的坐标变换函数scale_x_log10()等是变换坐标系，能够在视觉效果相同的情况下，使用原始数据的坐标刻度： load(&quot;datas/gapminder.rda&quot;) p=ggplot(gapminder,aes(gdpPercap, lifeExp)) + geom_point()+ geom_smooth() p+scale_x_continuous(labels = scales::dollar) ## `geom_smooth()` using method = &#39;gam&#39; and formula = &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; p+scale_x_log10(labels = scales::dollar) ## `geom_smooth()` using method = &#39;gam&#39; and formula = &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; 4.1.3.5 设置图形标题 用labs() 函数的参数title, subtitle, caption设置标题、副标题、脚注标题（默认右下角）： ggplot(mpg,aes(displ,hwy))+ geom_point(aes(color=drv))+ geom_smooth(se = FALSE)+ labs(title = &quot;燃油效率随引擎大小的变化图&quot;, subtitle = &quot;两座车(跑车) 因重量小而符合预期&quot;, caption = &quot;数据来自fueleconomy.gov&quot;)+ #国外习惯图形标题位于顶部左端，如果想改成顶部居中，需要加theme 图层专门设置 theme(plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5)) 4.1.3.6 设置fill, color 颜色 数据的某个维度信息可以通过颜色来展示，颜色直接影响图形的美感。可以直接使用颜色值，但是更建议使用RColorBrewer（调色板）或colorspace 包。 离散变量 manual: 直接指定分组使用的颜色 hue: 通过改变色相(hue) 饱和度(chroma) 亮度(luminosity) 来调整颜色 brewer: 使用ColorBrewer 的颜色 grey: 使用不同程度的灰色 用scale_*_manual()手动设置颜色，并修改图例及其标签： ggplot(mpg,aes(displ,hwy,color=drv))+ geom_point()+ scale_color_manual(&quot;驱动方式&quot;, #修改图例名 values = c(&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;), breaks = c(&quot;4&quot;,&quot;f&quot;,&quot;r&quot;), labels=c(&quot;四驱&quot;,&quot;前驱&quot;,&quot;后驱&quot;)) 用scale_*_brewer() 调用调色版中的颜色： ggplot(mpg,aes(x=class,fill=class))+ geom_bar()+ scale_fill_brewer(palette = &quot;Dark2&quot;) 查看所有可用的调色版：RColorBrewer::display.brewer.all()。 连续变量 gradient: 设置二色渐变色 gradient2: 设置三色渐变色 distiller: 使用ColorBrewer 的颜色 identity 使用color变量对应的颜色，对离散型和连续型都有效 用scale_color_gradient() 设置二色渐变色： ggplot(mpg, aes(displ, hwy, color = hwy)) + geom_point() + scale_color_gradient(low=&quot;green&quot;,high = &quot;red&quot;) 用scale_*_distiller() 调用调色版中的颜色： ggplot(mpg, aes(displ, hwy, color = hwy)) + geom_point() + scale_color_distiller(palette = &quot;Set1&quot;) 4.1.3.7 添加文字标注 ggrepel 包提供了geom_label_repel() 和geom_text_repel() 函数，为图形添加文字标注。 首先要准备好标记点的数据，然后增加文字标注的图层，需要提供标记点数据，以及要标注的文字给label 美学，若来自数据变量，则需要用映射。 library(ggrepel) best_in_class=mpg %&gt;% ## 选取每种车型hwy 值最大的样本 group_by(class) %&gt;% slice_max(hwy,n=1) ggplot(mpg,aes(displ,hwy))+ geom_point(aes(color=class))+ geom_label_repel(data = best_in_class,aes(label= model)) 若要在图形某坐标位置添加文本注释，则用annotate() 函数，需要提供添加文本的中心坐标位 置，和要添加的文字内容： ggplot(mpg,aes(displ,hwy))+ geom_point()+ annotate(geom = &quot;text&quot;,x = 6,y = 40, label=&quot;引擎越大\\n燃油效率越高!&quot;, size=4,color=&quot;red&quot;) 4.1.4 统计变换(Statistics) 4.1.4.1 为什么要做统计变换 ggplot(data = diamonds)+ geom_bar(mapping = aes(x=cut)) 我们可以看到，mapping中只有cut映射到了x轴，并没有制定什么变量映射到y轴而图案中y轴的count变量在元素数据中是没有的答案是geom_bar在暗地里做了一个统计变换（stat），新生成了一个叫count的变量。 4.1.4.2 统计变换（stat）与几何对象（geom）的关系 大部分stat和geom之间是可以相互转换的 举个例子 画出每个class（车型）对应计数的柱状图。 ggplot(mpg,aes(x = class))+ geom_bar()+ ggtitle(&quot;用geom_bar画图&quot;) ggplot(mpg,aes(x = class))+ stat_count()+ ggtitle(&quot;用stat_count画图&quot;) geom_bar()和stat_count()是等价的。即geom_bar()默认的stat=“count”，stat_count()默认的geom=“bar” 此外，我们也可以先手动变换好数据之后，再绘图。 data &lt;- mpg %&gt;% #手动变化数据，求每个class对应的合计 group_by(class) %&gt;% summarise( n_class=n()) data ## # A tibble: 7 × 2 ## class n_class ## &lt;chr&gt; &lt;int&gt; ## 1 2seater 5 ## 2 compact 47 ## 3 midsize 41 ## 4 minivan 11 ## 5 pickup 33 ## 6 subcompact 35 ## 7 suv 62 ggplot(data,aes(x = class, y=n_class))+ geom_bar(stat = &quot;identity&quot;)+ ggtitle(&quot;用geom_bar画图&quot;) ggplot(data,aes(x = class, y=n_class))+ geom_col()+ ggtitle(&quot;用geom_col画图&quot;) 在geom_bar()函数中更改stat参数从默认的”count”为”identity”后，和geom_col()函数等价，因为geom_col()函数默认的stat参数取值为”identity”。 例子二：绘制每个class对应出displ的合计。 data &lt;- (mpg %&gt;% # class的displ的求和 group_by(class) %&gt;% summarise( n_displ=sum(displ) )) data ## # A tibble: 7 × 2 ## class n_displ ## &lt;chr&gt; &lt;dbl&gt; ## 1 2seater 30.8 ## 2 compact 109. ## 3 midsize 120. ## 4 minivan 37.3 ## 5 pickup 146. ## 6 subcompact 93.1 ## 7 suv 276. ggplot(data = data,mapping = aes(x = class,y = n_displ))+ geom_bar(stat = &quot;identity&quot;)+ ggtitle(&quot;用自己手动变换数据做出来的条形图&quot;) ggplot(mpg,aes(x=class,y=displ)) + geom_bar(stat=&quot;identity&quot;)+ ggtitle(&quot;用stata=&#39;identity&#39;变换做出来的条形图&quot;) geom_bar()的position参数默认使用stack堆叠的方式，将所有柱子堆积成一根柱子,相当于对displ求和。 ggplot(mpg,aes(x=class,y=displ)) + stat_identity() # 散点图 ggplot(mpg,aes(x=class,y=displ)) + geom_point() # 等价于上一条 geom_point和stat_identity互相默认，即geom_point()函数的stata参数的默认取值为”identity”，stat_indentity()函数的geom参数的默认取值为”point”。 4.1.4.3 stat与geom的定义及使用 要理解stat和geom内部的运行机制，我们可以看ggplot2包中的User guides, package vignettes and other documentation.里面的文章 extending-ggplot2和知乎专栏。这篇文章介绍了如何自己创建一个新的geom和新的stat，创建新的函数需要我们遇到具体问题时才要去做的事情，在这里我只想通过理解它的创建过程，来理解原有函数之间的关系。 4.1.4.4 统计变换 构建新的统计量进而绘图，称为‘‘统计变换’’，简称‘‘统计’’。比如，条形图、直方图都是先对数 据分组，再计算分组频数（落在每组的样本点数）绘图；箱线图计算稳健的分布汇总，并用特殊盒子 展示出来；平滑曲线用来根据数据拟合模型，进而绘制模型预测值. . . . . . ggplot2 强大的一点就是，把统计变换直接融入绘图语法中，而不必先在外面对数据做统计变换， 再回来绘图。 ggplot2 中的提供了30 多种‘‘统计’’，均以stat_xxxx() 的方式命名。可以分为两类： 可以在几何对象函数geom_*() 中创建，通常直接使用后者即可 stat_bin()：geom_bar，geom_freqploy()，geom_histogram() stat_bindot()：geom_dotplot() stat_boxplot()：geom_box_plot() stat_contour()：geom_contour() stat_quantile()：geom_quantile() stat_smooth()：geom_smmoth() stat_sum()：geom_count() 不能在几何对象函数geom_*() 中创建： stat_ecdf(): 计算经验累积分布图 stat_function(): 根据x 值的函数计算y 值 stat_summary(): 在x 唯一值处汇总y 值 stat_qq(): 执行Q-Q 图计算 stat_spoke(): 转换极坐标的角度和半径为直角坐标位置 stat_unique(): 剔除重复行 用stat_summary() 做统计汇总并绘图。通过传递函数做统计计算，首先注意x 和y 美学映射到calss 和hwy; fun = mean是根据x计算y，故对每个车型计算一个平均的hwy；fun.max, fun.min 同样根据x分别计算y的均值加减标准差；统计计算的结果将传递给几何对象参数geom 用于绘图： ggplot(mpg,aes(x = class,y = hwy))+ geom_violin(trim = FALSE,alpha=0.5,color=&quot;green&quot;)+ stat_summary(fun=mean, fun.min = function(x){mean(x)-sd(x)}, fun.max = function(x){mean(x)+sd(x)}, geom = &quot;pointrange&quot;,color=&quot;red&quot;) 用stat_smooth(), 与geom_smooth() 相同, 添加光滑曲线： method: 指定平滑曲线的统计函数，如lm 线性回归, glm 广义线性回归, loess 多项式回归, gam 广义加法模型(mgcv 包) , rlm 稳健回归(MASS 包) 等 formula: 指定平滑曲线的方程，如y ~ x, y ~ poly(x, 2), y ~ log(x) ，需要与method 参数搭配使用 se: 设置是否绘制置信区间 ggplot(mpg,aes(displ,hwy))+ geom_point()+ stat_smooth(method = &quot;lm&quot;, formula = y~splines::bs(x,3), se = FALSE) 4.1.5 坐标系(Coordinante) ggplot2 默认坐标系是笛卡尔直角坐标系coord_cartesian()，常用的坐标系操作还有： coord_flip()：坐标轴翻转，即x 轴与y轴互换，比如绘制水平条形图 coord_fixed(): 固定ratio = y / x 的比例 coord_polar()：转化为极坐标系，比如条形图转为极坐标系即为饼图 coord_trans(): 彻底的坐标变换，不同于scale_x_log10() 等 coord_map(), coord_quickmap(): 与geom_polygon() 连用，控制地图的坐标投影 coord_sf(): 与geom_sf() 连用，控制地图的坐标投影 坐标轴翻转，从水平图到竖直图： ggplot(mpg,aes(class,hwy))+ geom_boxplot()+ #箱线图 coord_flip() # 从竖直变成水平 直角坐标下的条形图，转化为极坐标下的风玫瑰图： ggplot(mpg,aes(class,fill=drv))+ geom_bar()+ coord_polar() 4.1.6 位置调整(Position adjustments) 条形图中的条形位置调整： position_stack(): 竖直堆叠 position_fill(): 竖直(百分比) 堆叠，按比例放缩保证总高度为1 position_dodge(), position_dodge2(): 水平堆叠 ggplot(mpg,aes(class,fill=drv))+ geom_bar(position = position_dodge(preserve = &quot;single&quot;)) 散点图中的散点位置调整： position_nudge(): 将散点移动固定的偏移量 position_jitter(): 给每个散点增加一点随机噪声(抖散图) position_jitterdodge(): 增加一点随机噪声并躲避组内的点，特别用于箱线图+ 散点图 ggplot(mpg,aes(displ,hwy))+ geom_point(position = &quot;jitter&quot;) # 避免有散点重叠 有时候需要将多个图形排布在画板中，借助patchwork 包更方便。 library(patchwork) p1 = ggplot(mpg, aes(displ, hwy)) + geom_point() p2 = ggplot(mpg, aes(drv, displ)) + geom_boxplot() p3 = ggplot(mpg, aes(drv)) + geom_bar() p1|(p2/p3) 4.1.7 分面(Facet) 利用分类变量将图形分为若干个“面” （子图），即对数据分组再分别绘图，称为“分面” facet_wrap() 封装分面，先生成一维的面板系列，再封装到二维中。 分面形式：~ 分类变量, ~ 分类变量1 + 分类变量2 scales 参数设置是否共用坐标刻度，“fixed”（默认, 共用）, “free”（不共用），也可以用free_x,free_y 单独设置 参数nrow 和ncol 可设置子图的放置方式 ggplot(mpg,aes(displ,hwy))+ geom_point()+ facet_wrap(facets = ~drv,scales = &quot;fixed&quot;) ggplot(mpg,aes(displ,hwy))+ geom_point()+ facet_wrap(facets = ~drv+cyl,scales = &quot;fixed&quot;) facet_grid() 网格分面，生成二维的面板网格，面板的行与列通过分面变量定义。 分面形式：行分类变量~ 列分类变量 ggplot(mpg,aes(displ,hwy))+ geom_point()+ facet_grid(drv~cyl) 4.1.8 主题(theme) theme_bw() theme_light() theme_classic() theme_gray(): 默认 theme_linedraw() theme_dark() theme_minimal() theme_void() ggplot(mpg, aes(displ, hwy, color = drv)) + geom_point() + theme_bw() 更多的主题，还可以用ggthemes 包，其中包含一些顶级期刊专用绘图主题；当然也可以用theme()函数定制自己的主题（略）。 4.1.9 输出(output) 用ggsave() 函数，将当前图形保存为想要格式的图形文件，如png, pdf 等： ggsave(&quot;my_plot.pdf&quot;, width = 8, height = 6, dpi = 300) ##保存当前图形为pdf格式 最后，再补充一点关于图形中使用中文字体导出到pdf 等图形文件出现乱码问题的解决办法。 出现中文乱码是因为R 环境只载入了“sans (Arial),” “serif (Times New Roman),” “mono (Courier New)” 三种英文字体，没有中文字体可用。 解决办法就是从系统字体中载入中文字体，用showtext 包（依赖sysfonts 包）更简单一些。 font_paths(): 查看系统字体路径，windows 默认是C: font_files(): 查看系统自带的所有字体文件 font_add(): 从系统字体中载入字体，需提供family 名字，字体路径 载入字体后，再执行一下showtext_auto() (启用/关闭功能), 就可以使用该字体了。 ggpplot2 中各种设置主题、文本相关的函数*_text(), annotate() 等，都提供了family 参数，设定为font_add() 中一致的family 名字即可。 library(showtext) ## Loading required package: sysfonts ## Loading required package: showtextdb font_add(&quot;heiti&quot;, &quot;simhei.ttf&quot;) font_add(&quot;kaiti&quot;, &quot;simkai.ttf&quot;) showtext_auto() ggplot(mpg,aes(displ,hwy,color=drv))+ geom_point()+ theme(axis.title = element_text(family = &quot;heiti&quot;), plot.title = element_text(family = &quot;kaiti&quot;))+ xlab(&quot; 发动机排量(L)&quot;) + ylab(&quot; 高速里程数(mpg)&quot;) + ggtitle(&quot; 汽车发动机排量与高速里程数&quot;) + annotate(&quot;text&quot;, 5, 35, family = &quot;kaiti&quot;, size = 8, label = &quot; 设置中文字体&quot;, color = &quot;red&quot;) 4.1.10 export包(将ggplot或latice输出为PPT) export::graph2ppt(x=p$plot, file=&quot;F:/wlzp/AD_KM/p.pptx&quot;, width=5, height=3) 4.2 自定义ggplot2函数 4.2.1 为什么要自定义ggplot函数 每次在用ggplot函数绘图时，如果你只需要改变一个参数，每次都要复制粘贴所有绘图代码很麻烦。为了使您的代码更加灵活，您需要通过编写函数来减少重复代码。 4.2.2 单个组件 方法一：重复使用的代码片段存为对象 ggplot图的每个组件都是一个对象。大多数情况下，我们创建组件并立即将其添加到绘图中，但其实并不需要这么做。相反，我们可以将任何组件保存为一个变量（给它一个名字），然后将它添加到多个绘图中: bestfit &lt;- geom_smooth( method = &quot;lm&quot;, se=FALSE, colour=alpha(&quot;steelblue&quot;,0.5), size=2 ) ## Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0. ## ℹ Please use `linewidth` instead. ggplot(mpg,aes(cty,hwy))+ geom_point()+ bestfit ggplot(mpg,aes(displ,hwy))+ geom_point()+ bestfit 这是减少简单复制类型的一种方法(比复制粘贴好多了!)，但要求组件每次都完全相同。如果需要更大的灵活性，可以将这些可重复使用的代码片段放在在一个函数中。 方法二：重复使用的代码片段放在函数 例如，我们可以扩展bestfit对象成一个更普适性的函数，给图中增加一条最佳拟合线。下面的代码创建了一个geom_lm()函数，有三个参数，模型的formula，拟合线条的color和拟合线的粗细size： geom_lm &lt;- function(formula=y~x,color=alpha(&quot;steelblue&quot;,0.5), size=2,...){ geom_smooth(formula = formula,se=FALSE,method = &quot;lm&quot;,color=color, size=size,...) } ggplot(mpg, aes(displ, 1 / hwy)) + geom_point()+ geom_lm() ggplot(mpg,aes(displ,1/hwy))+ geom_point()+ geom_lm(y ~ poly(x,2),size=1,color=&quot;red&quot;) #等价于formula = y~x+I(x^2) 请注意”…“的用法。 在函数中定义缺省参数”…“允许函数接受任意的附加参数。 在函数内部，你可以使用”…” 将这些参数传递给另一个函数。 本例中，将”…“传递到geom_smooth()中，这样就可以修改我们没有显式覆盖的其他参数。 当编写自己的组件函数时，最好总是使用“…” 这种方式。 4.2.3 多个组件 4.3 散点图 4.3.1 密度散点图 绘制散点图时，若散点数目很多，散点之间相互重叠，则不易观察散点趋势，此时可绘制密度散点图解决。 加载R包并生成相关数据 library(ggplot2) library(dplyr) library(viridis) # 使用viridis提供的翠绿色标度：scale_fill_viridis() library(ggpointdensity) # 绘制密度散点图 library(cowplot) # 图形组合，可以自动对其坐标轴 dat &lt;- bind_rows( tibble(x = rnorm(7000, sd = 1), y = rnorm(7000, sd = 10), group = &quot;foo&quot;), tibble(x = rnorm(3000, mean = 1, sd = .5), y = rnorm(3000, mean = 7, sd = 5), group = &quot;bar&quot;)) 绘图 # 散点图 p1 &lt;- ggplot(data = dat, mapping = aes(x = x, y = y)) + geom_point() + labs(tag = &quot;A&quot;) + # 添加子图标记 theme_classic() # 散点图+密度线（geom_density2d） p2 &lt;- ggplot(data = dat, mapping = aes(x = x, y = y)) + geom_point() + geom_density2d(size = 1) + labs(tag = &quot;B&quot;) + theme_classic() # 封箱散点图（geom_bin2d） p3 &lt;- ggplot(data = dat, mapping = aes(x = x, y = y)) + geom_bin2d(bins = 60) + # bins控制着图中每个箱子的大小 scale_fill_viridis() + labs(tag = &quot;C&quot;) + theme_classic() # 密度散点图（geom_pointdensity） p4 &lt;- ggplot(data = dat, mapping = aes(x = x, y = y)) + geom_pointdensity() + scale_color_viridis() + labs(tag = &quot;D&quot;) + theme_classic() # 组合4幅图形 plot_grid(p1, p2, p3, p4, nrow = 2) 4幅图的比较 geom_point为ggplot2自带的绘图函数；A图各位置点的数量观察不清 geom_density2d为ggplot2自带的绘图函数，可以绘制密度等高线（图B） geom_bin2d为ggplot2自带的绘图函数；先将散点封箱处理，然后绘制出箱子，箱子的颜色取决于箱子内散点的数量（图C） geom_pointdensity为ggpointdensity包的函数；各散点的颜色取决于改点周围临近点的数量（图D） 图C与图D效果类似，但图C的箱子已不再是真实的散点，而图D为真实的散点；比较图C、图D与原始图A的散点稀疏区域便可发现 4.3.2 散点图+密度曲线 本部分参考知乎：散点图+直方图+密度曲线 #加载相关的包 library(ggplot2) library(ggExtra) library(cowplot) # 图形组合，可以自动对其坐标轴 #加载数据 dat &lt;- bind_rows( tibble(x = rnorm(500, sd = 1), y = rnorm(500, sd = 3), group = &quot;foo&quot;), tibble(x = rnorm(500, mean = 1, sd = .5), y = rnorm(500, mean = 7, sd = 2), group = &quot;bar&quot;)) p1 &lt;- ggplot(data = dat, mapping = aes(x = x, y = y)) + geom_point(aes(color=group))+ stat_smooth(method=lm)+ theme_bw()+ #黑白背景 theme(legend.position=&quot;none&quot;) #删除图注 #在散点图上添加密度曲线 p2 &lt;- ggExtra::ggMarginal(p1, type = &quot;density&quot;, #指定添加类型 xparams=list(fill = &quot;green&quot;), #指定颜色 yparams = list(fill=&quot;orange&quot;), #指定颜色 ) #在散点图上添加histogram p3 &lt;- ggExtra::ggMarginal(p1, type = &quot;histogram&quot;, #指定添加类型 xparams=list(fill = &quot;green&quot;), #指定颜色 yparams = list(fill=&quot;orange&quot;), #指定颜色 ) #根据性别分组添加密度曲线 p4 &lt;- ggExtra::ggMarginal(p1, type = &quot;density&quot;, xparams=list(fill = &quot;green&quot;), yparams = list(fill=&quot;orange&quot;), groupColour = T, groupFill=T #根据组别进行填充 ) plot_grid(p1, p2, p3,p4) 4.4 箱线图 一个分类变量的箱线图 绘制阿司匹林、P2Y抑制剂和双抗的PDC箱线图 #读入数据 data &lt;- readxl::read_excel(path =&quot;datas/箱线图/data.xlsx&quot;) head(data) ## # A tibble: 6 × 10 ## grbm PDC_of…¹ pdc_o…² index…³ index…⁴ p2y_t…⁵ PDC_o…⁶ pdc_o…⁷ PDC_o…⁸ pdc_o…⁹ ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 197 0.475 0.600 MI 0 氯吡格… 0.825 1 0.425 0.600 ## 2 637 0.575 0.600 UA 1 氯吡格… 1 1 0.575 0.600 ## 3 641 0.682 0.800 MI 0 氯吡格… 0.989 1 0.682 0.800 ## 4 741 0.0849 0.200 UA 0 氯吡格… 0.00822 0.200 0 0.200 ## 5 797 0.504 0.600 UA 0 氯吡格… 0.962 1 0.493 0.600 ## 6 1607 0.748 0.800 UA 0 混用 0.0521 0.200 0 0.200 ## # … with abbreviated variable names ¹​PDC_of_ASA, ²​pdc_of_ASA, ³​index_ACS_type, ## # ⁴​index_reval, ⁵​p2y_type, ⁶​PDC_of_P2Y, ⁷​pdc_of_P2Y, ⁸​PDC_of_DAPT, ## # ⁹​pdc_of_DAPT # 数据转换 data_1 &lt;- data %&gt;% select(grbm,PDC_of_ASA,PDC_of_P2Y,PDC_of_DAPT) %&gt;% pivot_longer(cols = PDC_of_ASA:PDC_of_DAPT,names_to = &quot;type&quot;,values_to = &quot;PDC_value&quot;) %&gt;% #变为长数据 mutate(type=factor(type,levels = c(&quot;PDC_of_ASA&quot;,&quot;PDC_of_P2Y&quot;,&quot;PDC_of_DAPT&quot;),labels = c(&quot;ASA&quot;,&quot;P2Y&quot;,&quot;DAPT&quot;))) #将type变量变为因子型，这样横坐标就可以按因子水平顺序排列 head(data_1) ## # A tibble: 6 × 3 ## grbm type PDC_value ## &lt;dbl&gt; &lt;fct&gt; &lt;dbl&gt; ## 1 197 ASA 0.475 ## 2 197 P2Y 0.825 ## 3 197 DAPT 0.425 ## 4 637 ASA 0.575 ## 5 637 P2Y 1 ## 6 637 DAPT 0.575 ggplot(data = data_1,aes(x = type,y = PDC_value))+ stat_boxplot(geom=&quot;errorbar&quot;,width=0.1,size=0.5,color=&quot;black&quot;)+ ##绘制误差棒 geom_boxplot( #绘制箱图 fill=&quot;#B5E7FF&quot;, size=0.5, width=0.5, color=&quot;black&quot;, notch = F, notchwidth = 0.5)+ theme(axis.title = element_text(size=18), axis.text = element_text(size=14))+ theme_bw() 绘制两个变量的箱线图 data_new &lt;- data %&gt;% select(grbm,index_reval,PDC_of_ASA,PDC_of_P2Y,PDC_of_DAPT) %&gt;% pivot_longer(cols = PDC_of_ASA:PDC_of_DAPT,names_to = &quot;type&quot;,values_to = &quot;PDC_value&quot;) %&gt;% mutate(index_reval=factor(index_reval,levels = c(1,0),labels = c(&quot;reval&quot;,&quot;non-reval&quot;)), type=factor(type,levels = c(&quot;PDC_of_ASA&quot;,&quot;PDC_of_P2Y&quot;,&quot;PDC_of_DAPT&quot;),labels = c(&quot;ASA&quot;,&quot;P2Y&quot;,&quot;DAPT&quot;))) head(data_new) ## # A tibble: 6 × 4 ## grbm index_reval type PDC_value ## &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; ## 1 197 non-reval ASA 0.475 ## 2 197 non-reval P2Y 0.825 ## 3 197 non-reval DAPT 0.425 ## 4 637 reval ASA 0.575 ## 5 637 reval P2Y 1 ## 6 637 reval DAPT 0.575 ggplot(data = data_new,aes(x = type,y = PDC_value))+ stat_boxplot(aes(fill=index_reval), geom=&quot;errorbar&quot;,width=0.1,size=0.5, position=position_dodge(0.6),color=&quot;black&quot;)+ geom_boxplot(aes(fill=index_reval),outlier.colour = NA, position=position_dodge(0.6), size=0.5, width=0.5, color=&quot;black&quot;, notch = F, notchwidth = 0.5)+ theme(axis.title = element_text(size=18), axis.text = element_text(size=14))+ theme_bw() 进阶 data_new &lt;- data %&gt;% select(grbm,index_reval,PDC_of_ASA,PDC_of_P2Y,PDC_of_DAPT) %&gt;% pivot_longer(cols = PDC_of_ASA:PDC_of_DAPT,names_to = &quot;type&quot;,values_to = &quot;PDC_value&quot;) %&gt;% mutate(index_reval=factor(index_reval,levels = c(1,0),labels = c(&quot;血运重建&quot;,&quot;非血运重建&quot;)), type=factor(type,levels = c(&quot;PDC_of_ASA&quot;,&quot;PDC_of_P2Y&quot;,&quot;PDC_of_DAPT&quot;),labels = c(&quot;ASA&quot;,&quot;P2Y&quot;,&quot;DAPT&quot;))) p &lt;- ggplot(data = data_new,aes(x = type,y = PDC_value))+ stat_boxplot(aes(fill=index_reval), geom=&quot;errorbar&quot;,width=0.1,size=0.5, position=position_dodge(0.6),color=&quot;black&quot;)+ geom_boxplot(aes(fill=index_reval),outlier.colour = NA, position=position_dodge(0.6), size=0.5, width=0.5, color=&quot;black&quot;, notch = F, notchwidth = 0.5)+ theme(axis.title = element_text(size=18), axis.text = element_text(size=14))+ theme_bw()+ scale_y_continuous(breaks = seq(0, 1.2, by = 0.2))+ scale_x_discrete(labels = c(&quot;ASA&quot; = &quot;阿司匹林&quot;, &quot;P2Y&quot; = &quot;P2Y抑制剂&quot;, &quot;DAPT&quot; = &quot;双抗&quot;))+ labs(x = &quot;药物类型&quot;, y = &quot;PDC&quot;,fill=&quot;分组&quot;) ##fill此处代表图例名，离散变量应该是col df1 &lt;- data.frame(a=c(0.85,0.85,1.15,1.15), b=c(1.02,1.05,1.05,1.02)) df2 &lt;- data.frame(a=c(1.85,1.85,2.15,2.15), b=c(1.02,1.05,1.05,1.02)) df3 &lt;- data.frame(a=c(2.85,2.85,3.15,3.15), b=c(1.02,1.05,1.05,1.02)) p &lt;- p+#按照设定的位置绘制横线 geom_line(data=df1,aes(a,b),cex=0.5)+ geom_line(data=df2,aes(a,b),cex=.5)+ geom_line(data=df3,aes(a,b),cex=.5)+ #添加显著性标记信息 annotate(&#39;text&#39;,x=1,y=1.08,label=&quot;p&lt;0.001&quot;, size=3,color=&#39;black&#39;)+ annotate(&#39;text&#39;,x=2,y=1.08,label=&quot;p&lt;0.001&quot;, size=3,color=&#39;black&#39;)+ annotate(&#39;text&#39;,x=3,y=1.08,label=&quot;p&lt;0.001&quot;, size=3,color=&#39;black&#39;) p 4.5 生存分析 前期数据处理 library(tidyverse) library(survival) library(survminer) file1 &lt;- foreign::read.dta(file = &quot;F:/wlzp/AD_KM/file1.dta&quot;) file2 &lt;- foreign::read.dta(file = &quot;F:/wlzp/AD_KM/file2.dta&quot;) data1 &lt;- tibble::tibble(grbm=file1$grbm, dy90=file1$signal90, dysj=file1$timetg, arm=file1$cohort) data2 &lt;- tibble::tibble(grbm=file2$grbm, dy90=file2$signal90, dysj=file2$timetg, arm=file2$cohort) data &lt;- bind_rows(data1,data2) %&gt;% mutate(cohort=case_when(arm==1 ~ &quot;treatment-naive&quot;, arm==2 ~ &quot;previously treated&quot;, arm==3 ~ &quot;totol&quot; )) %&gt;% select(-arm) 画生存曲线 fit&lt;-survfit(Surv(dysj,dy90 == 1)~cohort,data = data) p &lt;- ggsurvplot(fit,data = data, palette = c(&quot;#E7B800&quot;, &quot;#2E9FDF&quot;,&quot;#F39902&quot;), conf.int = TRUE, risk.table = FALSE, xlab= &quot;proportion of persistence %&quot;, ylab= &quot;proportion of persistence %&quot;, ggtheme = theme_bw(), # Change ggplot2 theme legend.title = c(&quot;&quot;), legend= &quot;right&quot;, legend.labs = c(&quot;treatment-naive&quot;,&quot;previously treated&quot;,&quot;totol&quot;), censor=FALSE) export::graph2ppt(x=p$plot, file=&quot;F:/wlzp/AD_KM/p.pptx&quot;, width=5, height=3) 4.6 Plotly 4.6.1 将ggplot对象转化为plotly对象 iris %&gt;% ggplot(aes(x=Sepal.Length,y=Sepal.Width,color=Species)) + geom_point() library(plotly) ggplotly(iris %&gt;% ggplot(aes(x=Sepal.Length,y=Sepal.Width,color=Species)) + geom_point()) library(survival) library(survminer) fit &lt;- survfit(Surv(time, status) ~ sex, data = lung) p &lt;- ggsurvplot( fit, # survfit object with calculated statistics. data = lung, # data used to fit survival curves. risk.table = FALSE, # show risk table. pval = FALSE, # show p-value of log-rank test. censor=FALSE, conf.int = TRUE, # show confidence intervals for # point estimates of survival curves. xlim = c(0,1000), # present narrower X axis, but not affect # survival estimates. xlab = &quot;Time in days&quot;, # customize X axis label. break.time.by = 100, # break X axis in time intervals by 500. ggtheme = theme_light(), # customize plot and risk table with a theme. ) ggplotly(p$plot) "],["描述性统计分析.html", "5 描述性统计分析 5.1 若干概念 5.2 （样本）统计量 5.3 统计图", " 5 描述性统计分析 5.1 若干概念 1. 随机变量 当一件事情的结果无法预料时，就叫随机现象。表示随机现象一组结果的变量就是随机变量。 比如说，调查了100 个人的身高，这100 个身高的数据是随机变量身高的 数据。并不是说这些身高值是不固定可变的，而是这100 个身高值是一次调 查的结果，再调查100 个人就是另一组不同的100 个身高值。 2. 概率分布 随机变量既然是这样随机的，还有必要研究它吗？有必要！因为把多个随机结 果放在一起的时候，能发现一定的规律性。比如100 人的身高可能对称地分 布在175cm 附近，离得越远人数越少，即表现出一种正态分布规律性。 随机现象五花八门，但每一种随机现象表现出来的规律性是固定的，用数学语 言表达出来就是概率分布。所以，不同概率分布就是不同随机现象规律性的数 学描述。 统计学最常用到四大概率分布：正态分布、t 分布、卡方分布、F 分布。 比如正态分布\\( (, ^2)\\),  和 （小写的sigma）就是参数，它们只要取不同值，就是不同的 分布形状。 3. 总体和样本 总体(population)：是包含所研究的全部个体（数据）的集合。 样本(sample)：从总体中抽取的一部分个体的集合，样本包含个体的数 目称为样本量。 抽样的目的是根据样本数据提供的信息推断总体的特征，或者说，用样本统计 量推断总体参数。 比如，要研究天津市成年男性的身高，则所有天津市成年男性的身高数据 就是总体，但实际上不可能把所有这些身高都测量一遍，只能是随机抽取一部 分，比如100 人，测得身高数据，这就是样本，样本量是100。 4. 参数与统计量 参数(parameter)：用来描述总体特征的概括性值，是研究者想要了解的 总体的某种特征值，如总体均值()、总体方差(2)、总体比例() 等 统计量(statistic)：是用来描述样本特征的概括性数字度量，是根据样本 数据计算出来的量，由于抽样是随机的，因此统计量是样本的函数。与 上面总体参数对应的统计量是样本均值 ()̄ 、样本标准差 (2)、样本比例 () 等。 由于总体数据通常是不知道的，故参数是未知常数。所以才进行抽样，根据样 本计算出相应统计量值去估计总体参数值。 5.2 （样本）统计量 5.2.1 数据位置的统计量 1. 均值(Mean) 均值，度量数据分布的中心位置： \\[ \\bar x=\\frac{1}{n} \\sum_{i=1}^{n}x_i \\] 2. 中位数(Median) 中位数，是位于最中间的那个数据，比中位数大和小的数据各占观测值的一半。 先将数据从小到大排序为：\\(x_{(1)}\\), ⋯ , \\(x_{()}\\)，然后计算 \\[ x_{0.5}= \\begin{cases} x_{(\\frac{n+1}{2})} &amp; n为奇数\\\\ \\frac{1}{2} (x_{(\\frac{n}{2})}+x_{(\\frac{n}{2}+1)}) &amp; n为偶数 \\end{cases} \\] 中位数的优点是具有稳健性，即不受个别极端数据的影响。一般来说，正态分 布的数据用均值描述，偏态分布的数据最好是用中位数描述。比如，人均工资 有被平均了的感觉，中位数工资才是更合适的中间收入。 3. 分位数(Quantile) 中位数是0.5 分位数，位于0.5 位置的数。 0.25 分位数，称为下四分位数(Q1), 是位于0.25 那个位置的数，即比它小 的数占比是0.25, 比它大的数占比是0.75。 0.75 分位数，称为上四分位数(Q3)。 更一般地，\\(\\) 分位数，是位于\\(\\) 位置的数，即比它小的数占比是\\(\\), 比它大的 数占比是\\(1 − \\). 或者说\\(\\) 的数比它小，\\((1 − )\\) 的数比它大。 4. 众数(Mode) 众数，是观测值中出现次数最多的数，对应分布的最高峰。众数常用于分类数 据，即出现频数最高的值。 5.2.2 数据分散程度的统计量 极差(Range) 极差，就是数据中的最大值和最小值之差 四分位距(Interquartile Range) 四分位距，是上下四分位数之差，即 \\[  = 3 − 1 \\] 样本方差(Variance) \\[ s^2=\\frac{1}{n-1} \\sum_{i=1}^{n} (x_i-\\bar x)^2 \\] 注意，分母除的是\\( − 1\\), 这是为了保证用样本方差估计总体方差时，得到的 是无偏估计。 这个\\( − 1\\) 也是自由度，在统计学中，几乎所有方法、所有统计量都会涉及自 由度。自由度，是计算样本统计量时能够自由取值的数值的个数。 总体方差公式（除以\\(\\)）时，是\\(\\) 个样本自由地从总体里抽取。但是样本方差 公式时多了一个约束条件，它们的和除以\\(\\)必须等于样本均值 \\(\\bar x\\)，所以自由度  减去1 个约束条件对自由度的损失，等于\\( − 1\\)。 不同统计方法的自由度都不一样，但基本原则是每估计1 个参数，就需要消耗 1 个自由度。 以回归分析为例，若有 个自变量，则需要估计 + 1 个参数（包含截距 项），所以模型的F 检验用到的自由度是 − ( + 1). 这意味着只剩下  − ( + 1) 个可以自由取值的数值用来估计模型误差 样本标准差(Standard Deviation) 样本方差的平方根即为标准差. 标准差的量纲与原数据一致。 变异系数(Coefficient of Variation) 变异系数，是将标准差占均值的百分比，可用于比较不同量纲数据的分散性： \\[ c_v=\\frac{s}{\\bar x} × 100\\% \\] 5.2.3 样本统计量的R实现 mean(x): 计算数值向量x 的均值 median(x): 计算数值向量x 的中位数 quantile(x, p): 计算数值向量x 的p 分位数 rstatix::get_mode(x): 计算向量x 的众数 max(x)-min(x): 计算数值向量x 的极差 IQR(x): 计算数值向量x 的四分位距 var(x): 计算数值向量x 的样本方差 sd(x): 计算数值向量x 的样本标准差 100*sd(x)/mean(x): 计算数值向量x 的变异系数 很多包提供了同时对多个变量进行（分组）描述汇总所有常见统计量的 函数，其中tidy 风格的是rstatix::get_summary_stats() 和 dlookr::describe(). library(rstatix) iris %&gt;% group_by(Species) %&gt;% get_summary_stats(type = &quot;full&quot;) ## # A tibble: 12 × 14 ## Species varia…¹ n min max median q1 q3 iqr mad mean sd ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 setosa Sepal.… 50 4.3 5.8 5 4.8 5.2 0.4 0.297 5.01 0.352 ## 2 setosa Sepal.… 50 2.3 4.4 3.4 3.2 3.68 0.475 0.371 3.43 0.379 ## 3 setosa Petal.… 50 1 1.9 1.5 1.4 1.58 0.175 0.148 1.46 0.174 ## 4 setosa Petal.… 50 0.1 0.6 0.2 0.2 0.3 0.1 0 0.246 0.105 ## 5 versico… Sepal.… 50 4.9 7 5.9 5.6 6.3 0.7 0.519 5.94 0.516 ## 6 versico… Sepal.… 50 2 3.4 2.8 2.52 3 0.475 0.297 2.77 0.314 ## 7 versico… Petal.… 50 3 5.1 4.35 4 4.6 0.6 0.519 4.26 0.47 ## 8 versico… Petal.… 50 1 1.8 1.3 1.2 1.5 0.3 0.222 1.33 0.198 ## 9 virgini… Sepal.… 50 4.9 7.9 6.5 6.22 6.9 0.675 0.593 6.59 0.636 ## 10 virgini… Sepal.… 50 2.2 3.8 3 2.8 3.18 0.375 0.297 2.97 0.322 ## 11 virgini… Petal.… 50 4.5 6.9 5.55 5.1 5.88 0.775 0.667 5.55 0.552 ## 12 virgini… Petal.… 50 1.4 2.5 2 1.8 2.3 0.5 0.297 2.03 0.275 ## # … with 2 more variables: se &lt;dbl&gt;, ci &lt;dbl&gt;, and abbreviated variable name ## # ¹​variable 5.3 统计图 描述统计是从不同方面对数据做了概要，想要进一步了解和探索数据，离不开 绘制统计图。不同类型的数据，适用不同类型的统计图。 5.3.1 分类数据的统计图 1. 条形图(Histogram) 条形图是最常用的类别比较图，是用竖直（或水平）的条形展示分类变量的分 布（频数），条形的高度代表频数。 geom_bar(): 对原始数据绘制条形图 geom_col(): 对汇总频数/频率的数据用绘制条形图 以starwars 数据集skin_color 绘制条形图为例： 用fct_lump() 将频数≤ 5 的类别做了合并 分组汇总，计算各组频数和频率 绘制条形图，将分类变量skin_color 按频率做了因子重排序，实现了对” 条形” 排序 在条形旁边增加文字注释，标记该条形所占百分比 翻转坐标轴，变成水平条形图 df &lt;- starwars %&gt;% mutate(skin_color = fct_lump(skin_color, n = 5)) %&gt;% count(skin_color, sort = T) %&gt;% mutate(p = n / sum(n)) df ## # A tibble: 6 × 3 ## skin_color n p ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Other 41 0.471 ## 2 fair 17 0.195 ## 3 light 11 0.126 ## 4 dark 6 0.0690 ## 5 green 6 0.0690 ## 6 grey 6 0.0690 ggplot(df, aes(fct_reorder(skin_color, p), p)) + geom_col(fill = &quot;steelblue&quot;) + # 汇总数据制作条形图 scale_y_continuous(labels = scales::percent) + ## 坐标轴标签由小数变成百分比形式 labs(x = &quot;皮肤颜色&quot;, y = &quot;占比&quot;) + geom_text(aes( y = p + 0.04, ## y的偏移量 label = str_c(round(p * 100, 1), &quot;%&quot;) ), ## 将多个字符串合并成一个字符串 size = 5, color = &quot;red&quot; ) + coord_flip() ## 翻转xy坐标轴 2. 饼图 待补充 5.3.2 连续数据的统计图 1. 直方图 连续数据常用直方图来展示变量取值的分布，利用直方图可以估计总体的概率 密度。 将变量取值的范围分成若干区间。直方图是用面积而不是用高度来表示数，总 面积是100%. 每个区间矩形的面积恰是落在该区间内的百分数（频率），所以 矩形的高= 频率/区间长度= 密度 特别地，若区间是等长的，则” 矩形的高” 就是频率。注意：直方图矩形之间是 没有间隔的。 用geom_histogram() 绘制直方图。频率直方图与概率密度曲线正好搭配， 因为频率直方图的条形宽度趋于0，就是概率密度曲线。 若想绘制频数直方图+ 概率密度曲线，就需要对密度做一个放大：条形宽度 * 样本数倍。 set.seed(123) df &lt;- tibble(heights = rnorm(10000, 170, 2.5)) ggplot(df, aes(x = heights)) + geom_histogram( fill = &quot;steelblue&quot;, color = &quot;black&quot;, binwidth = 0.5 ) + stat_function( fun = ~ dnorm(.x, mean = 170, sd = 2.5) * 0.5 * 10000, color = &quot;red&quot; ) 2. 箱线图 箱线图，是在一条数轴上： 以数据的上下四分位数(Q1-Q3) 为界画一个矩形盒子（中间50% 的数 据落在盒内）； 在数据的中位数位置画一条线段为中位线； 默认延长线为盒长的1.5 倍，之外的点认为是异常值。 箱线图的主要应用就是，剔除数据的异常值、判断数据的偏态和尾重、可视化 组间差异。 用geom_boxplot() 绘制箱线图，例如比较不同drv 下，hwy 的组间差异 ggplot(mpg, aes(x = drv, y = hwy)) + geom_boxplot() 均值线与误差棒图 以ToothGrowth 数据集为例，先自定义分组汇总函数计算分组均值和标准 误： my_summary &lt;- function(data, .summary_var, ...) { summary_var &lt;- enquo(.summary_var) data %&gt;% group_by(...) %&gt;% summarise( mean = mean(!!summary_var, na.rm = TRUE), sd = sd(!!summary_var, na.rm = TRUE) ) %&gt;% mutate(se = sd / sqrt(n())) } df &lt;- my_summary(ToothGrowth, len, supp, dose) df ## # A tibble: 6 × 5 ## # Groups: supp [2] ## supp dose mean sd se ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 OJ 0.5 13.2 4.46 2.57 ## 2 OJ 1 22.7 3.91 2.26 ## 3 OJ 2 26.1 2.66 1.53 ## 4 VC 0.5 7.98 2.75 1.59 ## 5 VC 1 16.8 2.52 1.45 ## 6 VC 2 26.1 4.80 2.77 pd &lt;- position_dodge((0.05)) ggplot(df, aes(dose, mean, color = supp, group = supp)) + geom_errorbar(aes(ymin = mean - se, ymax = mean + se), color = &quot;black&quot;, width = 0.1, position = pd ) + geom_line(position = pd) + geom_point(position = pd, size = 3, shape = 21, fill = &quot;white&quot;) + xlab(&quot; 剂量(mg)&quot;) + ylab(&quot; 牙齿生长&quot;) + scale_color_hue( name = &quot; 喂养类型&quot;, breaks = c(&quot;OJ&quot;, &quot;VC&quot;), labels = c(&quot; 橘子汁&quot;, &quot; 维生素C&quot;), l = 40 ) + scale_y_continuous(breaks = 0:20 * 5) 5.3.3 列联表 对分类变量做描述统计，通常是计算各水平值出现的频数和占比，得到列联表 （交叉表）。用table() 可以实现，但功能很弱还不够tidy. janitor 包提供了更强大的tabyl() 函数，可以生成一个、两个、三个变 量的列联表，再结合adorn_*() 函数，可以很方便地按想要的格式添加行 列合计、占比等。 一维列联表，添加合计行： library(janitor) ## Warning: package &#39;janitor&#39; was built under R version 4.2.3 ## ## Attaching package: &#39;janitor&#39; ## The following object is masked from &#39;package:rstatix&#39;: ## ## make_clean_names ## The following objects are masked from &#39;package:stats&#39;: ## ## chisq.test, fisher.test mpg %&gt;% tabyl(drv) %&gt;% adorn_totals(&quot;row&quot;) %&gt;% # 添加合计行 adorn_pct_formatting() # 设置百分比格式 ## drv n percent ## 4 103 44.0% ## f 106 45.3% ## r 25 10.7% ## Total 234 100.0% 二维列联表，添加列占比和频数 library(janitor) mpg %&gt;% tabyl(drv, cyl) %&gt;% adorn_percentages(&quot;col&quot;) %&gt;% # 添加列占比 adorn_pct_formatting(digits = 2) %&gt;% # 设置百分比格式 adorn_ns() # 添加频数 ## drv 4 5 6 8 ## 4 28.40% (23) 0.00% (0) 40.51% (32) 68.57% (48) ## f 71.60% (58) 100.00% (4) 54.43% (43) 1.43% (1) ## r 0.00% (0) 0.00% (0) 5.06% (4) 30.00% (21) "],["markdown.html", "6 Markdown 6.1 简介 6.2 行内格式 6.3 块级元素 6.4 行内块元素 6.5 数学公式", " 6 Markdown 6.1 简介 Markdown格式是John Gruber于2004年创造的， Markdown 的目标是实现“易读易写”。 Markdown定义了一种简单好用的文本文件格式， 作为单独的文本文件， 此格式没有什么多余的标签， 又可以转化为很多其它的格式。 Markdown 的语法全由一些符号所组成， 这些符号经过精挑细选，其作用一目了然。 比如：在文字两旁加上星号，看起来就像强调。 Markdown 的列表看起来就像我们平常在邮件中写一个列表的方法。 Markdown 的区块引用看起来就真的像是引用一段文字， 就像你曾在电子邮件中见过的那样。 需要时， 可以直接在markdown中写HTML标记内容。 markdown能实现的功能是HTML的一部分， 但是比HTML内容更干净， 没有掺杂过多的与要表达的意思无关的标签。 Markdown的理念是，能让文档更容易读、写和随意改。 6.2 行内格式 6.2.1 强调、上下标和行内代码 斜体：用星号或下划线包围的内容，如*斜体*或_斜体_是斜体格式。 粗体：一对双星号，如**粗体**是粗体格式。 星号、下划线与要强调或加重的内容之间不要空开， 否则会当作普通星号或下划线解释， 在行首还会当作列表。 为了插入普通的星号或下划线，可以使用反斜杠保护， 或者写成段内代码格式。 上下标：一对~是下标，如HO~2~会变成HO2。一对^是上标，如Cu^2+^会变成Cu2+。但是，数学公式一般还是应该使用LaTeX数学公式形式。 标记文本为行内代码，请使用一对反引号，例如`code`会被渲染为code 。要包含n个反引号，请在外部至少使用n + 1个反引号，例如，可以使用四个反引号来保留内部的三个反引号:```` ```code``` ````会被渲染为 ```code``` 6.2.2 超链接 (1) 原样显示的可点击的链接 只要把链接地址用小于号和大于号包在中间。 如果是网页，需要加http://， 如果是邮箱，需要加mailto:。 例如，如下代码: 刘卢路网页地址是： &lt;https://www.liululu.net/&gt; 。 显示为：刘卢路的网页地址是： https://www.liululu.net/ 。 (2) 行内式 外部链接： 请参考[刘卢路的主页](https://www.liululu.net/) 显示为：请参考刘卢路的主页 内部链接 用于文内跳转 在各级标题行的末尾， 可以添加{#自定义标签}这样的内容， 其中“自定义标签”是自己写的一个标识符， 标识符仅使用英文字母、数字、下划线、减号， 用来区分不同的位置。 比如，本章第一节“简介”添加了markdown-intro为标签， 就可以用“[回到介绍](#markdown-intro)”产生链接回到介绍。 (3) 引用式 使用引用式的链接， 有些像论文中把所有参考文献排列在文章末尾， 文中用到某一篇文献只要提及其序号。 [liululu]: http://liululu.net/ &quot;刘卢路&quot; 此时文章可以使用[刘卢路的网站][liululu]将链接变成刘卢路的网站 6.2.3 插入引用citations 待补充 见谢益辉https://bookdown.org/yihui/rmarkdown/markdown-syntax.html#inline-formatting，https://bookdown.org/yihui/bookdown/citations.html 6.2.4 换行空格 为了排版诗、词之类的内容， 希望人为控制换行和引导空格， 可以使用| | 枯藤老树昏鸦， | 小桥流水人家， | 古道西风瘦马。 | 夕阳西下， | 断肠人在天涯。 枯藤老树昏鸦，   小桥流水人家，   古道西风瘦马。 夕阳西下，   断肠人在天涯。 6.3 块级元素 6.3.1 代码块 普通代码块可以写在三个或更多的反引号```之后，你也可以将代码块缩进四个空格，例如: ``` x &lt;- rnorm(100) hist(x) ``` 或者缩进四个空格: x &lt;- rnorm(100) hist(x) 6.3.2 标题 标题写在井号#之后。 # 一级标题 ## 二级标题 ### 三级标题 如果不希望对某个标题进行编号，可以添加{-}或{.unnumbered}，例如。 # 不标号的二级标题 {-} 6.3.3 分割线 三个或三个以上连续的星号***组成的行， 可以转换成分隔线 6.3.4 块级元素引用（段落引用） 可以用类似Email的回复包含原始邮件内容的办法输入引用段落， 即，在段落的每行前面加一个大于号&gt;。 &gt; 白日依山尽，黄河入海流。 &gt; 欲穷千里目，更上一层楼。 注意引用也是段落模式，内容中的换行不起作用，空行导致分段。引用段落也可以仅在段落第一行写大于号， 其它行顶格写，例如下面的两段引用： &gt; 白日依山尽，黄河入海流。 &gt; &gt; 欲穷千里目，更上一层楼。 白日依山尽，黄河入海流。 欲穷千里目，更上一层楼。 引用也可以嵌套，如： &gt; 张三说：李四这样说过 &gt; &gt;&gt; 不想当将军的木匠不是好厨子。 &gt; 张三说：李四这样说过 不想当将军的木匠不是好厨子。 6.3.5 列表 (1) 无序列表 无序列表以*,-, 或+开始，还通过缩进子列表来嵌套列表。 - one item - one item - one item + one more item + one more item + one more item 显示为： one item one item one item one more item one more item one more item (2) 有序列表 有序列表以数字开头(同样可以在列表中嵌套列表)，例如。 1. the first item 2. the second item 3. the third item - one unordered item - one unordered item 显示为： the first item the second item the third item one unordered item one unordered item 6.4 行内块元素 6.4.1 图片 基础语法 ![Alt text](图片链接 &quot;optional title&quot;) Alt text：图片的Alt标签，用来描述图片的关键词，可以不写。最初的本意是当图片因为某种原因不能被显示时而出现的替代文字，后来又被用于SEO，可以方便搜索引擎根据Alt text里面的关键词搜索到图片。 图片链接：可以是图片的本地地址或者是网址。 “optional title”：鼠标悬置于图片上会出现的标题文字，可以不写。 (1) 网页图片 ![](http://www.baidu.com/img/baidu_jgylogo3.gif) 结果为 (2) 本地图片 只需要在基础语法的括号中填入图片的位置路径即可，支持绝对路径和相对路径。缺点是不灵活不好分享，本地图片的路径更改或丢失都会造成markdown文件调不出图。 ![avatar](fig/4/04-02-01.jpg) avatar (3) 引用式插入 [baidu]: http://www.baidu.com/img/baidu_jgylogo3.gif ![百度][baidu] 百度 6.5 数学公式 6.5.1 Markdown如何显示数学公式 原始的Markdown格式并不支持数学公式。 Pandoc扩展的markdown格式提供了对数学公式的支持， 可以在Markdown文件中插入LaTeX格式的数学公式。 虽然不能提供所有的LaTeX公式能力， 但是常用的数学公式还是能做得很好， 转换到HTML、docx都可以得到正常显示的公式。 用RStudio软件编译Markdown文件， 可以在其中插入LaTeX格式的数学公式， 数学公式可以在编辑器内部显示预览， 编译成HTML或者docx格式后都可以正常显示数学公式, HTML结果可以直接利用RStudio内部的浏览器预览， 在另外安装的LaTeX编译器的支持下也可以将.Rmd格式编译LaTeX格式然后再转换为PDF格式， 这种基于LaTeX的方法对数学公式的支持会更完善。 6.5.2 数学公式的类别 数学公式公式分为行内公式和独立公式。 行内使用LaTeX语法，写在两个美元符号$中间，或者\\(和\\)之间。例如$f(x)=\\frac{1}{2} \\int_0^1 \\sin^2 (t x) dt$会变成\\(f(x)=\\frac{1}{2} \\int_0^1 \\sin^2 (t x) dt\\)。开头和结尾的$后面不能在空格后面。 独立公式写在成对的美元符号中间，或者\\[和\\]之间。 例如： $$ f(x) = \\frac{1}{2} \\sum_{j=1}^\\infty \\int_0^1 \\sin^2(j t x) dt . $$ \\[ f(x) = \\frac{1}{2} \\sum_{j=1}^\\infty \\int_0^1 \\sin^2(j t x) dt . \\] 6.5.3 上横线 （1）overline $$ \\overline {X} $$ \\[ \\overline {X} \\] （2）bar $$ \\bar {X} $$ \\[ \\bar {X} \\] 6.5.4 hat $$ \\overline {Y} $$ \\[ \\overline {Y} \\] 6.5.5 换行对齐 用\\begin{aligned}和\\end{aligned} $$ \\begin{aligned} L(\\mu,\\sigma)&amp;=\\prod_{i=1}^{n} f(x_i,\\mu,\\sigma) \\\\ &amp;=\\prod_{i=1}^{n} \\frac{1}{\\sqrt{2 \\pi}\\sigma} e ^{- \\frac{(x-\\mu)^{2}}{2\\sigma^2}} \\\\ &amp; = (\\frac{1}{\\sqrt{2 \\pi} \\sigma})^n - \\sum_{i=1}^n \\frac{(x_i-\\mu)^2}{2\\sigma^2} \\end{aligned} $$ \\[ \\begin{aligned} L(\\mu,\\sigma)&amp;=\\prod_{i=1}^{n} f(x_i,\\mu,\\sigma) \\\\ &amp;=\\prod_{i=1}^{n} \\frac{1}{\\sqrt{2 \\pi}\\sigma} e ^{- \\frac{(x-\\mu)^{2}}{2\\sigma^2}} \\\\ &amp; = (\\frac{1}{\\sqrt{2 \\pi} \\sigma})^n - \\sum_{i=1}^n \\frac{(x_i-\\mu)^2}{2\\sigma^2} \\end{aligned} \\] 6.5.6 分段函数 用\\begin{cases}和\\end{cases} $$ f(x)= \\begin{cases} \\lambda e^{-\\lambda x}, &amp; x&gt;0\\\\ 0, &amp; x\\le0 \\end{cases} $$ \\[ f(x)= \\begin{cases} \\lambda e^{-\\lambda x}, &amp; x&gt;0\\\\ 0, &amp; x\\le0 \\end{cases} \\] "],["rmarkdown.html", "7 RMarkdown 7.1 RMarkdown简介 7.2 安装 7.3 基础 7.4 文档格式（HTML,PDF,Word…）", " 7 RMarkdown 7.1 RMarkdown简介 R Markdown文档中的文本是用Markdown语法编写的。确切地说，这是Pandoc的Markdownhttps://pandoc.org/MANUAL.html。 7.2 安装 你需要有R和RStudio。接下来需要安装rmarkdown包： # 从CRAN安装稳定版 install.packages(&#39;rmarkdown&#39;) # 从GitHub安装开发版 if (!requireNamespace(&quot;devtools&quot;)) install.packages(&#39;devtools&#39;) devtools::install_github(&#39;rstudio/rmarkdown&#39;) 如果想生成PDF格式的输出文件，需要安装LaTex。如果你没有安装过的话，可以安装TinyTeX。 install.packages(&#39;tinytex&#39;) tinytex::install_tinytex() # 安装TinyTeX 有了rmarkdown包、RStudio/Pandoc和LaTeX，就能够编译大多数R Markdown文档。在某些情况下，可能需要其他R包，我们将在用到时候再细说。 7.3 基础 7.3.1 RMarkdown基础 下面是一个最基础的R Markdown文档，它本身是一个纯文本文件，后缀名为.Rmd： --- title: &quot;Hello R Markdown&quot; author: &quot;Awesome Me&quot; date: &quot;2018-02-14&quot; output: html_document --- This is a paragraph in an R Markdown document. Below is a code chunk: ```{r} fit = lm(dist ~ speed, data = cars) b = coef(fit) plot(cars) abline(fit) ``` The slope of the regression is `r b[1]`. 如果你使用RStudio，你可以从菜单栏File -&gt; New File -&gt; R Markdown，创建RMarkdown文档。 R Markdown文档有三个基本组件:元数据metadata、文本text和代码code。元数据写在这对三个破折号之间---。元数据的语法是YAML (YAML不是标记语言)，因此有时它也被称为YAML元数据或YAML frontmatter。预先警告您缩进在YAML中很重要，所以不要忘记正确地缩进顶部字段top field的子字段sub-field。请参阅Xie(2016)的 附录B.2，以获得一些显示YAML语法的简单示例。 文档的主体在元数据之后。文本(也称为prose或narratives)的语法是Markdown。有两种类型的计算机代码: 代码块以三个反引号开始，比如```{r} ，其中r表示语言名称，以三个反引号结束。你可以在花括号中写入chunk选项(例如，设置图形高度为5英寸: ```{r, fig.height=5}。 行内R代码表达式以 `r开头，以 反引号`结尾。 然后可以单击Knit按钮来编译文档(到HTML页面)，页面默认输出在RStudio的Viewer窗口。 7.3.2 编写R Markdown文档 编译R Markdown文档的通常方法是点击Knit按钮，相应的键盘快捷键是Ctrl + Shift + K(在macOS上是Cmd + Shift + K)。在底层，RStudio在新的R会话中调用函数rmarkdown::render()渲染文档。请注意,在新的R会话中渲染Rmd文档意味着当前R会话中的对象(例如，在R控制台中创建的对象)都不会被渲染。可重现性是RStudio使用一个新的R会话来呈现Rmd文档的主要原因：文档在下次打开R或在其他人的计算环境中继续工作。 如果你必须在当前的R会话中呈现一个文档，你也可以自己调用rmarkdown::render()，并将Rmd文件的路径传递给这个函数。这个函数的第二个参数是输出格式，默认为您在YAML元数据中指定的第一个输出格式(如果缺少该格式，则默认为html_document)。当你在元数据中有多种输出格式，并且不想使用第一种格式时，你可以在第二个参数中指定你想要的格式，例如，对于Rmd文档foo.Rmd与元数据: output: html_document: toc: true pdf_document: keep_tex: true 可以通过一下命令渲染成PDF： rmarkdown::render(&#39;foo.Rmd&#39;, &#39;pdf_document&#39;) 编写Rmd文档的另一种主要方式是R Markdown Notebooks。暂不介绍。 最后，我想提到一种“非官方”的编译Rmd文档的方法：xaringan::inf_mr()函数，或者类似的，RStudio addin插件“Infinite Moon Reader”。显然，这需要您安装xaringan包(Xie 2021e)。这种方式的主要优势是liverload:一种技术使您可以在保存源文档时实时预览输出，而不需要点击Knit按钮。另一个特点是，它在当前R会话中编译Rmd文档，这可能是您所希望的，也可能不是。请注意，此方法只适用于输出到HTML的Rmd文档，包括HTML文档和演示文稿。 一些R Markdown扩展包，如bookdown和blogdown，有自己的编译文档的方式，我们将在后面介绍它们。 注意，也可以从一个R Markdown源文档呈现一系列报告，而不是单个报告。您可以参数化R Markdown文档，并使用不同的参数生成不同的报告。此坑后文补充。 7.3.3 备忘清单（Cheat sheet） RStudio创建了大量的备清单（cheat sheet），包括一页的R Markdown备忘单，可以在上免费获得。https://www.rstudio.com/resources/cheatsheets/ 7.3.4 输出格式 在rmarkdown包中有两种输出格式:文档和演示文稿。下面列出了所有可用的格式： beamer_presentation context_document github_document html_document ioslides_presentation latex_document md_document odt_document pdf_document powerpoint_presentation rtf_document slidy_presentation word_document 对于Rmd文件的YAML元数据中的输出格式名，如果格式来自于扩展包，你需要包含包名，例如: output: tufte::tufte_html 如果格式来自于rmarkdown包，则不需要加rmarkdown::前缀(尽管这不会有什么坏处)。 当文档中有多种输出格式时，RStudio Knit按钮后面会有一个下拉菜单，列出输出格式的名称。 每种输出格式通常都有几个格式选项。所有这些选项都记录在R包帮助页面中。例如，您可以在R中输入?rmarkdown::html_document打开html_document格式的帮助页面。当您想要使用某些选项时，您必须将值从R转换为YAML，例如: html_document(toc = TRUE, toc_depth = 2, dev = &#39;svg&#39;) 需要被写成： output: html_document: toc: true toc_depth: 2 dev: &#39;svg&#39; 注意，R’中的 TRUE, FALSE, 和 NULL 对于YAML的true, false, 和 null。YAML中的字符通常不需要引号括起来(e.g., dev: 'svg' and dev: svg是一样的),除非包含特殊字符, 例如冒号:。可临药 yaml 包进行检验是否需要引号, e.g., cat(yaml::as.yaml(list( title = &#39;A Wonderful Day&#39;, subtitle = &#39;hygge: a quality of coziness&#39; ))) title: A Wonderful Day subtitle: &#39;hygge: a quality of coziness&#39; 如果您的选项保护R的函数结果，则可以使用!expr，它会告诉yaml包需要解析和计算该选项。下面是一个在HTML输出中使用随机主题的例子 cat(yaml::as.yaml(list( title = &#39;A Wonderful Day&#39;, subtitle = &#39;hygge: a quality of coziness&#39; ))) title: A Wonderful Day subtitle: &#39;hygge: a quality of coziness&#39; 如果某个选项有子选项(这意味着这个选项的值是一个R的列表)，子选项需要进一步缩进，例如: output: html_document: toc: true includes: in_header: header.html before_body: before.html 一些选项被传递给knitr，例如dev、fig_width和fig_height。一些选项被传递给Pandoc，例如toc、toc_depth和number_sections。 output: pdf_document: toc: true pandoc_args: [&quot;--wrap=none&quot;, &quot;--top-level-division=chapter&quot;] 7.3.5 R代码块和R行内代码 可以使用RStudio工具栏(Insert按钮)或快捷键Ctrl + Alt + I (Cmd + Option + I)插入R代码块。 在代码块中可以做很多事情:可以生成文本输出、表格或图形。你可以通过块选项很好地控制所有这些输出，这些选项可以在大括号中设置(在```{r 和 }之间)。例如，你可以通过chunk选项results = 'hide'选择隐藏文本输出，或者通过fig.height = 4. 设置图形高度为4英寸。Chunk选项用逗号分隔，例如： ```{r, chunk-label, results=&#39;hide&#39;, fig.height=4} 在谢益辉的blog中https://yihui.name/knitr/options有大量的chunk选项。下面我们列出了其中的一个子集: 除了代码块标签（chunk label）不需要tag，仅需要输入value。其他选项都是通过键值对的形式输入tag=value。当然，代码块标签选项也可以显性采用键值对的形式输入label='自定义标签名'。每个代码块的标签是唯一的，如果没有手动指定其标签值，RMarkdown会自动命名为unnamed-chunk-i，i是增量的正数。 7.3.5.1 全局设置 如果某个选项需要在多个代码块中频繁地设置为一个值，你可以考虑在文档的第一个代码块（YAML的下方）中全局设置它，你可以使用knitr::opts_chunk$set()来改变文档中chunk选项的默认值。例如，你可以把它放在你文档的第一个代码块: 例子一： ```{r, setup, include=FALSE} knitr::opts_chunk$set(fig.width = 8, collapse = TRUE) ``` 例子二： ```{r, setup, include=FALSE} knitr::opts_chunk$set( comment = &#39;&#39;, fig.width = 6, fig.height = 6 ) ``` 7.3.5.2 代码执行（Code evaluation） eval：(TRUE；逻辑值或数字) 。是否运行代码块。它也可以是一个数值向量来选择要执行的R代码，例如，eval = c(1,3,4)将执行第一个、第三个和第四个R代码，而eval = -(4:5)将求值除第四个和第五个代码之外的所有代码。 7.3.5.3 文本输出（Text output） echo：(TRUE；逻辑值或数字)是否在输出文档中显示源代码。除了显示/隐藏源代码的TRUE/FALSE之外，我们还可以使用一个数值向量来选择在一个代码块中要显示的R代码，例如，echo = 2:3表示只显示第2和第3个代码，echo = -4表示排除第4个代码。 results：(`makeup`；字符)控制如何显示文本结果。注意，此选项仅适用于普通文本输出(对warnings、messages和errors不起作用)。取值如下: markup：默认的显示形式，可不写，本书返回的结果基本都是此默认值。 asis：文本输出为本身as-is，在文档中直接输出其结果 hold：一个代码块所有的代码都显示完， 才显示所有的结果。 hide：运行了代码后不显示运行结果。 collapse：(FALSE； 逻辑值)，是否将一个代码块中的源代码和输出写在同一个块(默认情况下，它们被写入不同的块) warning： (TRUE；逻辑值) ，是否在输出中保留警告。如果为FALSE，所有警告将在控制台中显示，而不是文档中显示。还可以输入数字，例如，3表示从这个代码块中显示第三个警告。 error：(FALSE；逻辑值)，默认代码发生错误error时会停止。如果想出现错误的情况下，后续代码继续允许的话，需要改为TRUE。如果希望得到错误警告并继续允许后续代码，则可以设置error = 0。 message: (TRUE; 逻辑值) 是否保留message()发出的消息 include: (TRUE; 逻辑值) 如果，变为FALSE则本代码段仅运行， 但是代码和结果都不写入到生成的文档中。 strip.white: (TRUE; 逻辑值) 是否删除输出中源代码块开头或结尾的空行 class.output: (NULL; 字符)添加到文本输出块中的类名向量。此选项仅适用于R Markdown中的HTML输出格式。例如,class.output = c('foo'， 'bar')，文本输出将被放置在&lt;pre class=\"foo bar\"&gt;&lt;/pre&gt;。 7.3.5.4 代码装饰（Code decoration） tidy: (FALSE)是否自动重新排列代码段， 使得代码段格式更符合规范。 TRUE : 调用formatR::tidy_source()函数自动重新排列代码段。 prompt: (FALSE; logical) TRUE代码用R的大于号提示符开始 comment: (‘##’; character) TRUE希望结果不用井号保护 highlight: (TRUE; logical) 是否以语法高亮显示源代码。 7.3.5.5 缓存（Cache） cache: (FALSE; logical) 为了保险起见， 可以尽量不使用缓存功能， 而是用save()功能将需要长时间结算的结果保存下来， 用load()载入然后输出到结果文档中。 7.3.5.6 图片（Plots） fig.width and fig.height: 指定生成的图形的宽度和高度， 单位是英寸（1英寸等于2.54厘米）。如果同时指定，也可以使用fig.dim = c(6, 4) 等价于 fig.width = 6 且 fig.height = 4。 下面给出一个长宽都是10厘米的图例。 ```{r fig.width=10/2.54, fig.height=10/2.54} curve(exp(-0.1*x)*sin(x), 0, 4*pi) abline(h=0, lty=3) ``` curve(exp(-0.1*x)*sin(x), 0, 4*pi) abline(h=0, lty=3) out.width和out.height控制输出文档中R图片的输出大小，即缩放图像。应百分比，例如out.width = '80%'表示图片为页面宽度的80%。 fig.align:图片的对齐方式. 取值可为'left', 'center', 或 'right'。 dev:记录R图的图形设备（graphical device）。通常情况下，LaTeX输出是'pdf'， HTML输出是'png'，但你当然可以使用其他设备，如'svg'或'jpeg'。 如果编译输出目标是HTML， 程序产生的图形是PNG格式， 属于点阵图， 图中的任何中文内容不会有乱码问题。 但是， 如果输出目标是PDF， 程序将产生PDF格式的图形， 这种图形属于矢量图， 需要正确设置文字编码才能保证图中的中文不会乱码。 设置的办法是用pdf.options()函数作如下指定： 其中的family选项指定了支持中文， 而height和width则是指定生成的每个图片的物理大小， 以英寸为单位。 这样的设定一般都放在Rmd文件开头， YAML后面的位置， 用setup作代码段标签， 加include=FALSE代码段选项表示仅运行但不使用运行得到的文字和图形输出结果。 7.3.6 插入图片 默认情况下，由R代码生成的图形将立即放置在生成图形的代码块之后。例如 ```{r} plot(cars, pch = 18) ``` (1) 图片标题 您可以在chunk选项中使用fig.cap选项设置图片标题。如果文档输出格式支持选项fig_caption: true(输出格式rmarkdown::html_document)， R图形将被放置到图形环境中。在PDF输出的情况下，这些数字将被自动编号。 （2） 图片并排显示 要将多个图形从相同的代码块并排放置，你可以使用fig.show='hold'选项和out.width的选项。下图示例，有两个图，每个图的宽度为50%。 ```{r hold-position, fig.cap=&#39;Two plots side-by-side.&#39;, fig.show=&#39;hold&#39;, out.width=&#39;50%&#39;, fig.width=5, fig.height=4} par(mar = c(4, 4, .2, .1)) plot(cars, pch = 19) plot(pressure, pch = 17) ``` 图7.1: Two plots side-by-side. (3) 非R代码生成的图片 如果需要显示不是由R代码生成的图形，可以使用knitr::include_graphics()函数，它比的Markdown语法更能控制图像的属性。 ```{r, out.width=&#39;25%&#39;, fig.align=&#39;center&#39;, fig.cap=&#39;...&#39;} knitr::include_graphics(&#39;images/hex-rmarkdown.png&#39;) ``` 图7.2: The R Markdown hex logo. 7.3.7 表格 显示表格最简单方法是使用knitr::kable()，它可以创建HTML, PDF和Word输出的表可以通过向设置caption参数来包含表标题，例如: ```{r tables-mtcars} knitr::kable(iris[1:5, ], caption = &#39;A caption&#39;) ``` 表7.1: A caption Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 如果您正在寻找表格样式化的更高级控制，建议您使用 kableExtra。 7.3.8 行内代码 除了代码块，你也可以在行内文本中插入R对象的值. 例如： ```{r} x = 5 # 圆的半径 ``` 如果一个圆的半径为 `r x`， 它的面积等于 `r pi * x^2`。 显示为 x = 5 # 圆的半径 如果一个圆的半径为 5, 它的面积等于78.5398163。 7.3.9 在RMarkdown使用其他语言 关于R Markdown的一个鲜为人知的事实是，它还支持许多其他语言，如Python、Julia、c++和SQL。这种支持来自knitr包，它提供了大量的语言引擎，你可以通过以下方式列出所有可用引擎的名称: names(knitr::knit_engines$get()) ## [1] &quot;awk&quot; &quot;bash&quot; &quot;coffee&quot; &quot;gawk&quot; &quot;groovy&quot; ## [6] &quot;haskell&quot; &quot;lein&quot; &quot;mysql&quot; &quot;node&quot; &quot;octave&quot; ## [11] &quot;perl&quot; &quot;php&quot; &quot;psql&quot; &quot;Rscript&quot; &quot;ruby&quot; ## [16] &quot;sas&quot; &quot;scala&quot; &quot;sed&quot; &quot;sh&quot; &quot;stata&quot; ## [21] &quot;zsh&quot; &quot;asis&quot; &quot;asy&quot; &quot;block&quot; &quot;block2&quot; ## [26] &quot;bslib&quot; &quot;c&quot; &quot;cat&quot; &quot;cc&quot; &quot;comment&quot; ## [31] &quot;css&quot; &quot;ditaa&quot; &quot;dot&quot; &quot;embed&quot; &quot;eviews&quot; ## [36] &quot;exec&quot; &quot;fortran&quot; &quot;fortran95&quot; &quot;go&quot; &quot;highlight&quot; ## [41] &quot;js&quot; &quot;julia&quot; &quot;python&quot; &quot;R&quot; &quot;Rcpp&quot; ## [46] &quot;sass&quot; &quot;scss&quot; &quot;sql&quot; &quot;stan&quot; &quot;targets&quot; ## [51] &quot;tikz&quot; &quot;verbatim&quot; &quot;theorem&quot; &quot;lemma&quot; &quot;corollary&quot; ## [56] &quot;proposition&quot; &quot;conjecture&quot; &quot;definition&quot; &quot;example&quot; &quot;exercise&quot; ## [61] &quot;hypothesis&quot; &quot;proof&quot; &quot;remark&quot; &quot;solution&quot; &quot;glue&quot; ## [66] &quot;glue_sql&quot; &quot;gluesql&quot; library(reticulate) x = &#39;hello, python world!&#39; print(x.split(&#39; &#39;)) ## [&#39;hello,&#39;, &#39;python&#39;, &#39;world!&#39;] 后续待补充。 7.3.10 交互式文档 R Markdown文档也可以生成交互式内容。有两种类型的交互式R Markdown文档:您可以使用HTML Widgets（HTML控件）框架，或Shiny框架(或两者都使用)。它们将后文中详细描述。 7.3.10.1 HTML widgets（HTML控件） HTML Widgets框架是在R包htmlwidgets 中实现的，它可以连接JavaScript，创建交互式应用程序(如交互式图形和表格)。基于这个框架已经开发了几个widget包，如DT，leaflet和dygraphs 。访问https://www.htmlwidgets.org了解有关widget包的更多信息，以及如何自己开发widget包。 显示了通过leaflet创建的交互式地图，下面是源文档 ```{r out.width=&#39;100%&#39;, echo=FALSE,warning=FALSE} library(leaflet) leaflet() %&gt;% addTiles() %&gt;% setView(117.1730089187622, 39.107918850334265, zoom = 17) %&gt;% addPopups( 117.1730089187622, 39.107918850334265, &#39;这里是 &lt;b&gt;天津大学&lt;/b&gt;&#39; ) ``` 7.3.10.2 Shiny文档 shiny包构建了由R驱动的交互式web应用程序。要从R Markdown文档中调用shiny代码，需要将runtime: shiny添加到YAML元数据中，就像下面这个文档: --- title: &quot;A Shiny Document&quot; output: html_document runtime: shiny --- A standard R plot can be made interactive by wrapping it in the Shiny `renderPlot()` function. The `selectInput()` function creates the input widget to drive the plot. ```{r eruptions, echo=FALSE} selectInput( &#39;breaks&#39;, label = &#39;Number of bins:&#39;, choices = c(10, 20, 35, 50), selected = 20 ) renderPlot({ par(mar = c(4, 4, .1, .5)) hist( faithful$eruptions, as.numeric(input$breaks), col = &#39;gray&#39;, border = &#39;white&#39;, xlab = &#39;Duration (minutes)&#39;, main = &#39;&#39; ) }) ``` 7.4 文档格式（HTML,PDF,Word…） Markdown最初的版本主要是为了更容易地编写HTML内容。例如，你可以写一个项目符号，可以用Markdown的- text，而不是冗长的HTML代码&lt;ul&gt;&lt;li&gt;text&lt;/li&gt;&lt;/ul&gt;，或者引用，使用&gt;text代替&lt;blockquote&gt; text &lt;/blockquote&gt;。 Markdown的语法已经被Pandoc大大扩展。此外，Pandoc还可以将Markdown文档转换为多种输出格式。在本章中，我们将介绍各种文档输出格式的特性。 7.4.1 HTML 要从R Markdown创建HTML文档，你需要在文档的YAML元数据中指定html_document输出格式： --- title: Habits author: John Doe date: March 22, 2005 output: html_document --- 7.4.2 目录（Table of contents） 您可以使用toc选项添加一个目录(Table of contents，TOC)，并使用toc_depth选项指定它所应用的标题深度。例如: --- title: &quot;Habits&quot; output: html_document: toc: true toc_depth: 2 --- 如果没有指定目录深度，默认值为3(目录将展示所有1、2和3级的标题)。 7.4.2.1 浮动目录 可以设定toc_float选项将目录浮动到主文档内容的左侧。即使在滚动文档时，浮动目录也总是可见的。例如: --- title: &quot;Habits&quot; output: html_document: toc: true toc_float: true --- 你可以为toc_float参数指定一个选项列表来控制它的行为。这些选项包括: collapsed (默认TRUE) 控制目录是否只显示顶级头部(例如，H2)。如果最初折叠，则在必要时自动内联展开目录。 smooth_scroll (默认TRUE) 控制当点击鼠标导航到TOC项目时页面滚动是否动画。 例如 --- title: &quot;Habits&quot; output: html_document: toc: true toc_float: collapsed: false smooth_scroll: false --- 7.4.3 小节编号Section numbering 您可以使用number_sections选项为标题添加节编号 --- title: &quot;Habits&quot; output: html_document: toc: true number_sections: true --- 7.4.4 Tabbed sections 待补充 7.4.5 外观和样式（Appearance and style） 有几个选项可以控制HTML文档的外观: theme指定页面使用的Bootstrap主题(主题从Bootswatch主题包中绘制)。有效的主题包括 default默认, cerulean天蓝, journal期刊, flatly平摊, darkly黑暗, readable可读, spacelab太空实验室, united统一, cosmo阈值, lumen流明, paper纸, sandstone砂石, simplex简单, 和 yeti雪人。对于没有主题可设置为null(在这种情况下，你可以使用css参数来添加你自己的样式)。 highlight显示指定语法高亮显示样式。支持的风格包括default默认,tango探戈, pygments颜料, kate凯特, monochrome单色, espresso浓缩, zenburn, haddock黑线鳕, breezedark微风方舟, 和 textmate。null不语法高亮显示。 例子： --- title: &quot;Habits&quot; output: html_document: theme: united highlight: tango --- 7.4.5.1 自定义CSS 你可以使用CSS选项将自己的CSS添加到HTML文档中: --- title: &quot;Habits&quot; output: html_document: css: styles.css --- 如果你想从你自己的CSS中提供文档的所有样式，你可以设置theme和highlight为null: --- title: &quot;Habits&quot; output: html_document: theme: null highlight: null css: styles.css --- 你也可以通过在文档的章节标题中添加id或类来使用定制CSS来针对文档的特定章节。例如下面的小节标题: ## Next Steps {#nextsteps .emphasized} 可以让你使用以下CSS选择器将CSS应用到它的所有内容: #nextsteps { color: blue; } .emphasized { font-size: 1.2em; } 7.4.6 图片选项（Figure options） fig_width和fig_height可用于控制默认图形的宽度和高度(默认使用7x5)。 fig_retina指定用于retina显示的缩放(默认为2，目前适用于所有广泛使用的retina显示)。设置为null可防止视网膜结垢。 fig_caption控制是否将图片渲染为标题。 dev控制用于渲染图形的图形设备(默认为png)。 例子 --- title: &quot;Habits&quot; output: html_document: fig_width: 7 fig_height: 6 fig_caption: true --- 7.4.7 数据框显示（Data frame printing） 您可以通过df_print选项增强数据框的默认显示。有效值见表 表7.2: html_document 格式df_print 选项可能的取值 选项 描述 default Call the print.data.frame generic method kable Use the knitr::kable function tibble Use the tibble::print.tbl_df function paged Use rmarkdown::paged_table to create a pageable table A custom function Use the function to create the table 7.4.7.1 Paged printing 当df_print选项设置为paged 时，表将被打印为支持行和列分页的HTML表。例如(见图 7.3): --- title: &quot;Motor Trend Car Road Tests&quot; output: html_document: df_print: paged --- ```{r} mtcars ``` 图7.3: A paged table in the HTML output document. Table 7.3 paged tables的可能选项. 表7.3: paged HTML tables的可能选项. 选项 描述 max.print The number of rows to print. rows.print The number of rows to display. cols.print The number of columns to display. cols.min.print The minimum number of columns to display. pages.print The number of pages to display under page navigation. paged.print When set to FALSE turns off paged tables. rownames.print When set to FALSE turns off row names. 这些选项在每个块中的设置如下: ```{r cols.print=3, rows.print=3} mtcars ``` 7.4.7.2 自定义函数（Custom function） df_print选项还可以采用任意函数在输出文档中创建表格。这个函数必须根据使用的输出以正确的格式输出。 例如 rmarkdown::html_document(df_print = knitr::kable) 等价于使用\"kable\"方法 rmarkdown::html_document(df_print = &quot;kable&quot;) 要在YAML头文件中使用df_print中的自定义函数，必须使用!expr标签，这样它之后的R表达式才会被求值。详见帮助页面?yaml::yaml.load的eval.expr参数。 --- title: &quot;Motor Trend Car Road Tests&quot; output: html_document: df_print: !expr pander::pander --- ```{r} mtcars ``` 7.4.8 代码折叠（Code folding） code_folding属性设置HTML结果中代码折叠选项， 取值hide可以隐藏代码， 但读者通过选项可见。 取值show可以显示代码， 但读者通过选项可隐藏代码显示。 例子 --- title: &quot;Habits&quot; output: html_document: code_folding: hide --- 7.4.9 MathJax数学公式的支持 Rmd格式支持数学公式， 在生成的HTML、Word、PDF中都可以正常显示数学公式， RStudio软件内部的浏览器也可以直接显示数学公式。 以HTML为输出时， 会使用MathJax库显示数学公式。 这是一个用于在浏览器中显示数学公式的Javascript程序库， 显示效果很好， 还支持多种显示实现方式， 支持包括LaTeX在内的多种数学公式输入方法。 R Markdown原来使用MathJax版本2， 现在MathJax已经发布了版本3， 有很大的改动， 我们这里应仍使用版本2。 MathJax库很大， 所以一般是从其网站按需远程调用的， 但是远程调用MathJax库在网络不畅通时会使得公式显示极为缓慢甚至无法显示， 所以Rmd允许将MathJax本地化。 在.Rmd文件头部YAML元数据的某种HTML输出格式的属性中， 设置属性mathjax: local就可以使得MathJax库被放在生成的HTML的一个下层目录中。 设置如 For example, to use a local copy of MathJax: --- title: &quot;Habits&quot; output: html_document: mathjax: local self_contained: false --- 注意设置mathjax: local同时必须设置self_contained: false。 在不使用本地MathJax副本时， 可以设置self_contained: true， 这使得图形文件、JavaScript代码等依赖项也打包在生成的单一HTML文件中， 如果设为false， 这些依赖文件会存放在单独文件中。 可以用lib_dir属性指定一个子目录用来存放这些依赖文件， 多个Rmd文件可以共用同一个lib_dir值。 将MathJax用mathjax: local属性本地化有明显的缺点。 这时，每个Rmd项目都需要一个MathJax库副本， 使得文件备份变得很麻烦。 下面的设置方法可以令多个Rmd项目共享一个共同的本地MathJax库。 To use a self-hosted copy of MathJax: --- title: &quot;Habits&quot; output: html_document: mathjax: &quot;http://example.com/MathJax.js&quot; --- To exclude MathJax entirely: --- title: &quot;Habits&quot; output: html_document: mathjax: null --- 7.4.10 文档依赖关系（Document dependencies） 默认情况下，R Markdown生成独立的HTML文件，没有外部依赖关系，使用data:URIs合并链接脚本、样式表、图像和视频的内容。这意味着您可以像共享Office文档或pdf一样共享或发布该文件。如果你更愿意将依赖关系保存在外部文件中，你可以指定self_contained: false。例如: --- title: &quot;Habits&quot; output: html_document: self_contained: false --- 保留外部依赖项的一个常见原因是为了从网站上提供R Markdown文档(外部依赖项可以被浏览器单独缓存，从而加快页面加载时间)。在提供多个R Markdown文档的情况下，您可能还希望将相关库文件(例如Bootstrap和MathJax等)合并到多个文档共享的单个目录中。您可以使用lib_dir选项来完成此操作。例如: --- title: &quot;Habits&quot; output: html_document: self_contained: false lib_dir: libs --- 7.4.11 保留md文件 当knitr包处理R Markdown输入文件时，它会创建一个Markdown (*.md)文件，该文件随后被Pandoc转换成HTML。如果你想在渲染后保留Markdown文件的副本，你可以使用keep_md选项: --- title: &quot;Habits&quot; output: html_document: keep_md: true --- 7.4.12 Includes 使用includes选项，在文档头部或文档主体之前/之后包含内容可以在增加HTML内容或替换核心Pandoc模板。 --- title: &quot;Habits&quot; output: html_document: includes: in_header: header.html before_body: doc_prefix.html after_body: doc_suffix.html --- 7.4.13 自定义模板 您也可以使用template选项替换底层的Pandoc模板 Custom templates 7.4.14 Markdown extensions 默认情况下，R Markdown被定义为所有的Pandoc Markdown扩展，并为与旧Markdown包的向后兼容性进行了以下调整 您可以使用md_extensions选项启用或禁用Markdown扩展(在选项前面加上-禁用和+启用)。例如: --- title: &quot;Habits&quot; output: html_document: md_extensions: -autolink_bare_uris+hard_line_breaks --- 上面的代码将禁用autolink_bare_uri扩展，并启用hard_line_breaks扩展。 7.4.15 Pandoc参数 待补充。 7.4.16 共享选项设置（Shared options） 如果希望指定一组默认选项，由一个目录中的多个文档共享，可以包含一个名为_output的文件。目录中的Yml。注意，这个文件中没有使用YAML分隔符(---)或output字段。与_output位于同一目录下的所有文档，yaml将继承它的选项。例如: html_document: self_contained: false theme: united highlight: textmate 而不应该被写成 --- output: html_document: self_contained: false theme: united highlight: textmate --- 7.4.17 HTML 片段（ HTML fragments） 如果要创建HTML片段而不是完整的HTML文档，可以使用html_fragment格式。例如: --- output: html_fragment --- 注意，HTML片段不是完整的HTML文档。它们不包含HTML文档所包含的标准头部内容(它们只包含&lt;body&gt;标签内的内容)。他们可以被包含在其他网页或内容管理系统(如博客)中。因此，它们不支持像主题或代码突出显示这样的特性(预期它们最终在处理这些事情的环境中发布)。 "],["bookdown.html", "8 Bookdown 8.1 简介 8.2 创建图书 8.3 编辑图书（Editing） 8.4 项目结构 8.5 Markdown extensions 8.6 输出格式", " 8 Bookdown 8.1 简介 R的bookdown扩展包(https://github.com/rstudio/bookdown) 是继knitr和rmarkdown扩展包之后， 另一个增强markdown格式的扩展， 使得Rmd格式可以支持公式、定理、图表自动编号和引用、链接， 文献引用和链接等适用于编写书籍的功能。 在bookdown的管理下一本书的内容可以分解成多个Rmd文件， 其中可以有可执行的R代码， R代码生成的文字结果、表格、图形可以自动插入到生成的内容中， 表格和图形可以是浮动排版的。 输出格式主要支持gitbook格式的网页图书， 这种图书在左侧显示目录， 右侧显示内容， 并可以自动链接到上一章和下一章； 通过单独安装的LaTeX编译器支持将书籍转换为一个PDF文件， 支持中文； 可以生成ePub等格式的电子书。 主要用于编写有多个章节的书籍， 也可以用来生成单一文件的研究报告。 建议使用RStudio集成环境制作这样的图书， 该软件内建了一键编译整本书的功能。 需要安装bookdown扩展包的最新版本。 bookdown扩展包现在还比较新， 还有一些BUG， 所以尽可能使用最新版的bookdown扩展包并且及时更新RStudio软件。 查看编译的网站建议使用Google Chrome浏览器， 此浏览器对gitbook的支持较好。 “bookdown: Authoring Books and Technical Documents with R Markdown” (https://bookdown.org/yihui/bookdown/) 因为中文需要一些特殊的设置， 以及在网络条件不好的条件下支持数学公式显示， 北京大学的李东风提供了一个中文书bookdown模板， 下载链接为:https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/bookdown-template-v0-5.zip。此外还有黄湘云的提供的ElegantBookdownhttps://github.com/XiangyunHuang/ElegantBookdown。本书采用的是李东风的模板制作。 8.2 创建图书 可以安装CRAN版或GitHub development版 # install from CRAN install.packages(&#39;bookdown&#39;) # or GitHub devtools::install_github(&#39;rstudio/bookdown&#39;) 在RStudio中，可以在菜单栏中点击 File -&gt; New Project -&gt; New Directory -&gt; Book Project using bookdown，即可创建bookdown，然后在RStudio中点击build按钮，将编译图书并在RStudio Viewer中显示HTML版本。图 8.1. 图8.1: bookdon模板的HTML输出 8.3 编辑图书（Editing） 8.3.1 构建图书（Build the book） 要将所有Rmd文件构建为一个book，可以调用bookdown::render_book()函数。它使用_output.yml(如果存在)中指定的设置。如果在其中指定了多个输出格式，则将构建所有格式。如果您使用的是RStudio，这可以通过Build选项卡完成。如果您只想构建一种格式，请打开下拉菜单“Build Book”。 图8.2: (ref:bookdown-build) 8.3.2 预览章节（Preview a chapter） 当书的大小很大或书中包含大量计算时，构建整本书可能会很慢。我们可以在bookdown中使用preview_chapter()函数一次只构建一个章节。同样，你也可以点击RStudio中的Knit按钮。 8.3.3 实时预览（Serve the book） 你可以使用bookdown::serve_book()函数来实时预览图书，而不是每次想要查看更改时都运行render_book()或preview_chapter()。任何时候保存Rmd文件，书将自动重新编译，预览将更新以反映变化。 8.3.4 RStudio 插件（RStudio addins） bookdown包为RStudio提供了两个插件，可以帮助编辑书籍: “Preview Book”:这个调用bookdown::serve_book()函数来编译并提供这本书。 “Input LaTeX Math”:提供了一个文本框，允许你写LaTeX方程，以避免在输入原始LaTeX数学表达式时常见的错误。 8.4 项目结构 下面是一个默认的bookdown项目的基本结构: directory/ ├── index.Rmd ├── 01-intro.Rmd ├── 02-literature.Rmd ├── 03-method.Rmd ├── 04-application.Rmd ├── 05-summary.Rmd ├── 06-references.Rmd ├── _bookdown.yml ├── _output.yml ├── book.bib ├── preamble.tex ├── README.md └── style.css index.Rmd: 这是唯一包含YAML frontmatter的Rmd文档 Rmd files: 一个典型的bookdown 图书包含多个章节，每个章节都存在于一个单独的Rmd文件中。 _bookdown.yml:bookdown的配置文件 _output.yml:指定HTML、LaTeX/PDF和e-books的格式。 preamble.tex 和 style.css: 它们可以用来调整图书输出文档的外观和样式。需要具备具备LaTeX和/或CSS知识。 下面的小节将更详细地解释这些文件。 8.4.1 首页文件（Index file） index.Rmd文件包含第一章和YAML元数据，例如: --- title: &quot;A Minimal Book Example&quot; author: &quot;Yihui Xie&quot; date: &quot;`r Sys.Date()`&quot; site: bookdown::bookdown_site documentclass: book bibliography: [book.bib, packages.bib] biblio-style: apalike link-citations: yes description: &quot;This is a minimal example of using the bookdown package to write a book.&quot; --- 其中在三个减号组成的两行之间的内容叫做YAML元数据， 是一本书的设置， 上例中有书的标题、作者名、日期（用R程序自动生成）、描述。 其中的site选项很重要， 一定要有这个选项， site: bookdown::bookdown_site使得RStudio软件能辨认这是一个bookdown图书项目， 从而为其提供一键编译快捷方式。 元数据中output项指定默认的输出格式。 documentclass项为借助LaTeX编译PDF格式指定LaTeX的模板， 现在还不能支持ctexbook模板所以使用了book模板。 bibliography项指定一个或者几个.bib格式的文献数据库。 8.4.2 Rmd文件（ Rmd files） 默认情况下，index.Rmd文件所有Rmd文件会共同渲染图书。Rmd文件必须是标题，如# 章节名，YAML元数据不应该包含在这些Rmd文件中，因为它继承index.Rmd文件。 默认情况下，bookdown按文件名的顺序合并所有Rmd文件，例如01-intro，将出现在02-literature.Rmd之前。以下划线_开头的文件名将被跳过。 01-intro.Rmd # Introduction This chapter is an overview of the methods that we propose to solve an **important problem**. 02-literature.Rmd # Literature Here is a review of existing methods. 8.4.3 _bookdown.yml _bookdown.yml文件允许你指定可选的设置来构建这本书。例如，你可能想通过包含rmd_files字段来覆盖文件合并的顺序: rmd_files: [&quot;index.Rmd&quot;, &quot;02-literature.Rmd&quot;, &quot;01-intro.Rmd&quot;] 8.4.4 _output.yml _output.yml文件用于指定图书输出格式(参 8.6)。下面是一个简单的例子: bookdown::gitbook: lib_dir: assets split_by: section config: toolbar: position: static bookdown::pdf_book: keep_tex: yes bookdown::html_book: css: toc.css 8.5 Markdown extensions bookdown包对中概述的Markdown语法进行了扩展，并提供了额外的功能强大的特性，以帮助更长的文档和学术写作。 8.5.1 公式编号 （1） 自动编号 首先把公式放在equation或align环境，其次使用语法(\\#eq:label)给label命名。 其中label是自己给公式的文字标签，在bookdown中，公式标签必须以eq:开头。例如 \\begin{equation} E=mc^2 (\\#eq:emc) \\end{equation} \\[\\begin{equation} E=mc^2 \\tag{8.1} \\end{equation}\\] \\begin{align} f(x) =&amp; \\sum_{k=0}^\\infty \\frac{1}{k!} x^k (\\#eq:efunc-sum) \\\\ = e^x (\\#eq:efunc-ex) \\end{align} \\[\\begin{align} f(x) =&amp; \\sum_{k=0}^\\infty \\frac{1}{k!} x^k \\tag{8.2} \\\\ = e^x \\tag{8.3} \\end{align}\\] （2） 手动编号 在用$$符号在两端界定的公式后面， 可以用命令增加人为的公式编号，如 $$ y = f(x) \\tag{*} $$ \\[ y = f(x) \\tag{*} \\] 8.5.2 定理和证明（Theorems and proofs） 感觉不是很好用。 要写一个定理，你可以使用下面的语法: ```{theorem, pyth, name=&quot;Pythagorean theorem&quot;} 对于直角三角形, 如果 $c$ 表示斜边的长度 ，$a$ 和 $b$ 表示另外两条边的长度，则 $$a^2 + b^2 = c^2$$ ``` 定理8.1 (勾股定理) 对于直角三角形, 如果 \\(c\\) 表示斜边的长度 ，\\(a\\) 和 \\(b\\) 表示另外两条边的长度，则 \\[a^2 + b^2 = c^2\\] 定理环境的变量包括:lemma引理、推论、命题、猜想、定义、例子、练习和``假设。证明环境的变体包括注释和解决方案。这些环境的语法类似于定理环境，例如： 8.5.3 特殊标题（Special headers） 在bookdown中可以使用两种特殊类型的一级标题: 内容相近的章节可以作为一个“部分”。在一个部分的第一个章节文件的章标题前面增加一行， 以# (PART)开头， 以{-}结尾，中间是部分的名称。# (PART) Part Title {-}。 # (PART) 随机数和随机模拟 {-} 书的最后可以有附录， 附录的章节将显示为A.1, B.1这样的格式。 为此， 在附录章节的第一个文件开头加如下的第一行标题行： # (APPENDIX) 附录 {-} 8.5.4 文本引用（Text references） 文本引用是带有标签label的段落。语法是(ref:label)text，其中label是唯一的标识符，而text是Markdown段落。例如: (ref:foo) **此处**定义一个文本引用 然后你可以使用(ref:foo)来引用全文。文本引用可以在文档的任何地方使用，在为图片指定长标题或在标题中包含Markdown格式时特别有用。例如: 一些文字 (ref:cool-plot) **base** R中`iris`数据的箱线图 ```{r cool-plot, fig.cap=&#39;(ref:cool-plot)&#39;} boxplot(Sepal.Length ~ Species, data = iris) ```` 8.5.5 交叉引用 bookdown包扩展了R Markdown文档中的交叉引用，允许自动交叉引用节标题、表格、图形、方程和定理。这只适用于编号的环境，因此需要为图形和表格分配标签。交叉引用的格式是\\@ref(type:label)，其中label是块标签，type是被引用的环境。为例: 标题Headers: # 简介 {#intro} 参考见第 \\@ref(intro) 章 图: 见图 \\@ref(fig:cars-plot) ```{r cars-plot, fig.cap=&quot;随便起的图名&quot;} plot(cars) # 一个散点图 ``` 表格: 见表 \\@ref(tab:mtcars) ```{r mtcars} knitr::kable(mtcars[1:5, 1:5], caption = &quot;随便起的表名&quot;) ``` 定理 See Theorem \\@ref(thm:boring) ```{theorem, boring} Here is my theorem. ``` 公式 见公式 \\@ref(eq:linear) \\begin{equation} a + bx = c (\\#eq:linear) \\end{equation} labels名只允许 (a-z, A-Z, 0-9), -, /,和 : 8.6 输出格式 bookdown 包括以下输出格式: HTML: gitbook html_book tufte_html_book PDF: pdf_book e-book: epub_book Single documents: html_document2 tufte_html2 pdf_document2 tufte_handout2 tufte_book2 word_document2 8.6.0.1 HTML 对gitbook格式， 即HTML网页格式， 编译完成后会弹出一个预览窗口， 其中的“Open in Browser”按钮可以将内容在操作系统默认的网络浏览器中打开。 另一种办法是在命令窗口用如下命令编译（以输出gitbook为例）， 我个人认为这种办法更好用： bookdown::render_book(&quot;index.Rmd&quot;, output_format=&quot;bookdown::gitbook&quot;, encoding=&quot;UTF-8&quot;) "],["写轮眼.html", "9 写轮眼 9.1 前期配置 9.2 键盘快捷键 9.3 幻灯片格式 9.4 建立和预览幻灯片 9.5 独立HTML输出设置 9.6 CSS和主题 9.7 一些提示和小技巧 9.8 总结术语", " 9 写轮眼 9.1 前期配置 （1）安装R包 install.packages(&quot;xaringan&quot;) （2）创建R Markdown文档 打开RStudio，从菜单栏点击File -&gt; New File -&gt; R Markdown -&gt; From Template -&gt; Ninja Presentation(Simplified Chinese) （3） 点击 Knit 按钮编译文档 点击 Knit按钮，RStudio会编译，并 实时预览幻灯片（每次你保存文档的时候，它会自动重新编译）。 原理： xaringan 将 R Markdown 的查克拉注入了 remark.js。浏览器中的幻灯片是 remark.js 渲染出来的，而它的 Markdown 源文档是从 R Markdown 生成的（实际上主要是 knitr）。 （4） 查看输出 xaringan 包提供了一个 R Markdown 输出格式 xaringan::moon_reader，你可以在 R Markdown 文档的元数据中使用它，例： --- title: &quot;啧啧啧，厉害啊&quot; author: &quot;张三&quot; date: &quot;2016年12月12日&quot; output: xaringan::moon_reader nature: autoplay: 30000 highlightStyle: github --- nature 下面的 autoplay 选项可以用来自动播放幻灯片，它的取值是毫秒，例如每 30 秒播放一张片子 nature 下面的 countdown 选项可以为每一页幻灯片添加一个（倒数）计时器，取值同样为毫秒，例如每一页片子都用 60 秒倒计时： output: xaringan::moon_reader: nature: countdown: 60000 选项 highlightLines: true 可以让以 * 开头或者双重大括号 {{ }} 里面的代码被高亮出来； output: xaringan::moon_reader: nature: highlightLines: true 我们举两个栗子 9.2 键盘快捷键 p 进入演讲者模式（可看见写给自己的注释，比如提醒自己要讲的笑话） c 复制幻灯片到新窗口；演讲时可以在自己面前的屏幕上显示演讲者模式，把新窗口中正常的幻灯片拖到大屏幕投影上给观众看。 9.3 幻灯片格式 remark（remark.js）是一个简单的基于浏览器的 Markdown 幻灯片工具。 9.3.1 幻灯片的属性 每个新幻灯片都是在三个破折号（dashes）(—)下创建的。破折号后面必须直接跟一个换行符（line break），并且在破折号后面不能有任何其他字符(甚至空格space)。当您看到新幻灯片出现在前一张幻灯片的水平线之后时，可能在三个破折号之后有空格(如果有，您必须删除空格)。 幻灯片的内容可以是任意的，它不一定有幻灯片标题，如果有，标题可以是任何级别(#，##，或###)。 一个幻灯片可以有一些CSS属性，包括class类和background-image背景图像等。属性写在幻灯片的开头，例如。 --- class: center, inverse background-image: url(&quot;images/cool.png&quot;) # A new slide Content. class属性将给幻灯片的HTML标签定义类名，这样就可以使用CSS为特定的幻灯片设置样式。例如，设置类名为inverse的幻灯片，可以定义CSS规则(在黑色背景上以白色呈现文本): .inverse { background-color: #272822; color: #d6d6d6; text-shadow: 0 0 20px #333; } 然后调用CSS文件，本例是通过月读xaringan::moon_reader:来调用my-style.css --- output: xaringan::moon_reader: css: &quot;my-style.css&quot; --- 实际上，inverse的样式已经在xaringan的默认主题中定义，所以实际上不需要再次定义它，除非想重新定义并覆盖它。 其他的可用类名包括幻灯片所有元素的水平对齐，left，center和right，以及垂直对齐，top，middle和bottom。 背景图片可通过background-image属性设置。路径应该放在url()中，这是CSS语法。你也可以设置背景图像的大小size和位置position，例如: background-image: url(&quot;`r xaringan:::karl`&quot;) background-position: center background-size: contain 所有这些属性都要求略懂CSS。在上面的示例中，我们实际上使用了一个行内表达式xaringan::karl来返回karl Broman 图像的URL，这是xaringan包的亮点之一。 9.3.2 首页标题幻灯片 标题幻灯片（即首页幻灯片），它是从Rmd文档的YAML元数据自动生成的。它包含标题title、副标题subtotal、作者author和日期date(都是可选的)。该幻灯片默认有inverse、center、middle和title-slide类，类似于图7.1中的左侧图像。如果你不喜欢默认样式，你可以自定义。title-slide类，或者通过nature选项下的titleSlideClass选项提供自定义的类向量，例如， --- output: xaringan::moon_reader: nature: titleSlideClass: [&quot;right&quot;, &quot;top&quot;, &quot;my-title&quot;] --- 你也可以通过seal选项禁止自动标题，然后手动输入： --- output: xaringan::moon_reader: seal: false --- # My Own Title ### Author Whatever you want to put on the title slide. 9.3.3 内容类 您也可以为幻灯片上的任何元素分配类。语法是.classname [content]。这是remark.js的一个非常强大的特性，也是Pandoc中为数不多的不可用的特性之一。它可以通过CSS为幻灯片上的任何元素设置样式。有一些是内置的内容类，.left[]， .center[]和.right[]来水平对齐幻灯片上的元素，例如，你可以将图像居中: .center[![description of the image](images/foo.png)] []内部的内容可以是任何内容，比如几个段落或列表。xaringan的默认主题提供了另外四个内容类 .left-column[]和.right-column[]提供侧栏sidebar布局。左边的侧边栏很窄(幻灯片宽度的20%)，右边的栏是主栏(幻灯片宽度的75%)。如果你在左栏中有多个2级(##)或3级(###)标题，最后一个标题将被突出显示，而之前的标题将被灰色化。 .pull-left[]和.pull-right[]提供两列two-column布局，两列宽度相同。下面是一个例子: .pull-left[ - One bullet. - Another bullet. ] .pull-right[ ![an image](foo.png) ] 如果你知道CSS，你可以设计自己的内容类，例如，如果你想通过.red[]使文本为红色，你可以在CSS中定义: .red { color: red; } 9.3.4 出现动画 您可以使用两个破折号来分隔内容。这两个破折号可以出现在除了内容类内部的任何地方，所以你基本上可以以任何你喜欢的方式分割你的内容，例如， --- # Two dashes The easiest way to build incremental slides is... -- to use two dashes `--` to separate content on a slide. -- You can divide a slide in _any way you want_. -- - One bullet - Another bullet -- - And one more -- .center[ ![Saw](https://slides.yihui.name/gif/saw-branch.gif) Don&#39;t saw your slides too hard. ] 9.3.5 演讲者注释 在主讲人模式下(按键盘快捷键p)，你可以自己写笔记，笔记下面有三个问号???语法也是Markdown，这意味着您可以编写Markdown支持的任何元素，比如段落、列表、图像等等。例如: --- The holy passion of Friendship is of so sweet and steady and loyal and enduring a nature that it will last through a whole lifetime... ??? _if not asked to lend money_. --- Mark Twain 演讲中一个常见的错误，尤其是对于没有太多经验的演讲者来说，就是在幻灯片中塞进太多的内容。结果要么是演讲者上气不接下气，大声读出这么多单词，要么是观众开始自己静静地读幻灯片，而不去听。幻灯片不是论文或书籍，所以你应该尽量在幻灯片的视觉内容上简洁，而在口头叙述上变长。如果你对一张幻灯片有很多要说的，但不能记住所有的内容，你可以考虑使用演示笔记。 9.3.6 yolo(you only live once) 可随机在幻灯片中插入一张图片，不常用。 --- output: xaringan::moon_reader: yolo: img: kangaroo.jpg times: 5 --- 在幻灯片中随机插入kangaroo.jpg5次。 9.4 建立和预览幻灯片 一种方式是点击knit按钮来预览。 另一种方式是在RStudio addin点击 “Infinite Moon Reader”或输入xaringan::inf_mr()函数，只要保存，就自动knit并预览。 9.5 独立HTML输出设置 与其他R Markdown输出格式相比，xaringan::moon_reader的一个区别是，默认情况下它不会生成独立的HTML文档。这意味着在默认情况下，外部依赖项(如图像或JavaScript库)不会嵌入到HTML输出文件中。您可以通过将独立自包含模式打开 `xaringan::moon_reader` 由于技术上的困难（remark.js并不是用Pandoc而是使用Markdown在浏览器中渲染），就算设置了独立自包含模式，有时候也不一定完全弄好。 目前如果想独立自包含图片的话，仅仅可以使用 ![](PATH)(Markdown syntax), &lt;img src=\"PATH\" /&gt; (HTML syntax), 和background-image: url(PATH)(remark.js syntax for background images)这几种方式，其他方式嵌入图片不会被独立自包含模式识别。 9.6 CSS和主题 在format的xaringan::moon_reader中有一个css选项，可以向该选项传递一个css文件路径向量. 举个栗子。比如你想将一段文字的颜色改为红色，你可以定义一个 CSS 类，如： .red { color: #FF0000; } 我们把这段代码保存在一个 CSS 文件中，如 extra.css（假设它跟你的 R Markdown 文件在同一文件夹下），然后通过 css 选项将它引入： --- output: xaringan::moon_reader: css: [&quot;default&quot;, &quot;extra.css&quot;] --- 现在在 R Markdown 中你就可以用 .red[] 来标记一段文字为红色，如 .red[我是红色的]。 理论上，文件路径应该包含扩展名.css。如果路径不包含文件名扩展名，则假定它是xaringan包中的内置CSS文件。例如，上面示例中的default表示包中路径xaringan:::pkg_resource()下的default.css。要查看所有内置的CSS文件，调用R中的xaringan:::list_css()。 当你只想覆盖默认主题中的一些CSS规则时，你不需要复制整个文件default. CSS;相反，创建一个新的(更小)CSS文件，只提供新的CSS规则。 用户已经为xaringan贡献了一些主题。例如，您可以使用metropolis主题。 查看所有可能的主题 names(xaringan:::list_css()) ## [1] &quot;chocolate-fonts&quot; &quot;chocolate&quot; &quot;default-fonts&quot; &quot;default&quot; ## [5] &quot;duke-blue&quot; &quot;fc-fonts&quot; &quot;fc&quot; &quot;glasgow_template&quot; ## [9] &quot;hygge-duke&quot; &quot;hygge&quot; &quot;ki-fonts&quot; &quot;ki&quot; ## [13] &quot;kunoichi&quot; &quot;lucy-fonts&quot; &quot;lucy&quot; &quot;metropolis-fonts&quot; ## [17] &quot;metropolis&quot; &quot;middlebury-fonts&quot; &quot;middlebury&quot; &quot;nhsr-fonts&quot; ## [21] &quot;nhsr&quot; &quot;ninjutsu&quot; &quot;rladies-fonts&quot; &quot;rladies&quot; ## [25] &quot;robot-fonts&quot; &quot;robot&quot; &quot;rutgers-fonts&quot; &quot;rutgers&quot; ## [29] &quot;shinobi&quot; &quot;tamu-fonts&quot; &quot;tamu&quot; &quot;uio-fonts&quot; ## [33] &quot;uio&quot; &quot;uo-fonts&quot; &quot;uo&quot; &quot;uol-fonts&quot; ## [37] &quot;uol&quot; &quot;useR-fonts&quot; &quot;useR&quot; &quot;uwm-fonts&quot; ## [41] &quot;uwm&quot; &quot;wic-fonts&quot; &quot;wic&quot; 9.7 一些提示和小技巧 9.7.1 自动放映 如果你在nature(毫秒)下设置autoplay自动播放选项，幻灯片可以自动播放。例如，下一张幻灯片可以在闪电对话中每30秒自动显示一次: 9.7.2 倒计时计时器 一个倒计时计时器可以添加到每一页的幻灯片使用倒计时选项下的自然。例如，如果你想在演讲时花一分钟在每一页上，你可以设置: --- output: xaringan::moon_reader: nature: countdown: 60000 --- 然后你会看到一个计时器从01:00，到00:59,00:58，…当时间结束时，计时器将继续，但时间变成红色。 9.7.3 高亮代码行 选项highlightLines: true of nature将突出显示以*开头的代码行，或者{{}}括起来的代码行，或者末尾有#&lt;&lt; --- output: xaringan::moon_reader: nature: highlightLines: true --- 下面是几个小栗子 https://bookdown.org/yihui/rmarkdown/some-tips.html#highlight-code-lines 注意，第一种方法不能在源文档中提供有效的R代码，但是后两种方法提供语法上有效的R代码，并且在输出幻灯片中，您不会看到标记{{}}或#&lt;&lt;。默认情况下，这些行将以黄色背景突出显示。 9.7.4 离线模式 要让幻灯片离线工作，你需要提前下载一个remark.js的副本，因为xaringan默认使用在线版本。你可以使用xaringan::summon_remark()来下载最新的或指定版本的remark.js。默认情况下，它被下载到libs/remark-latest.min.js。也就是当前项目相对的lib文件夹中。 然后更改YAML元数据中的chakra选项以指向该文件，例如， output: xaringan::moon_reader: chakra: libs/remark-latest.min.js 9.7.5 宏指令Macros remark.js的Markdown语法具有惊人的可扩展性，因为它允许用户定义自定义宏(JavaScript函数)，这些宏可以使用语法应用于Markdown文本 等学了JavaScript之后再来补充 9.7.6 打印PDF 当从谷歌Chrome将幻灯片打印为PDF格式时，我建议您打开幻灯片并浏览所有页面至少一次，以确保所有内容已经在浏览器中呈现。如果不一次性手动浏览所有幻灯片，有些内容可能无法正确打印(例如MathJax表达式和HTML小部件)。 9.8 总结术语 简单介绍一下这个包里那些奇怪的术语的由来： 写轮眼（包名，名字来源于火影中的写轮眼 Sharingan） 月读（我希望这个 R Markdown 格式 moon_reader 能将听众控制在幻象中） 查克拉（月读的参数之一 chakra，意思是 remark.js 的路径，它是支撑幻灯片的核心动力） 性质变化（月读的参数之一 nature，意思是通过设置选项改变查克拉的性质） 无限月读（函数 infinite_moon_reader() 开启一个服务器不断刷新更新后的幻灯片，RStudio 插件背后对应的就是这个函数） 通灵术（summon_remark() 从网络上把 remark.js 通灵到本地） "],["数据集介绍.html", "10 数据集介绍 10.1 mpg数据集", " 10 数据集介绍 10.1 mpg数据集 mpg（Mileage per gallon performances of various cars）数据集是关于“各种车型每加仑英里数表现”的数据。它包含1999年至2008年间每年都有新版本的型号 - 被用于衡量汽车的受欢迎程度。 数据格式：有234个观测（行）和11个变量（列）。 变量含义 表10.1: mpg数据集变量解释 缩写 全称 中文解释 manufacturer manufacturer name 制造商 model model name 型号 displ engine displacement, in litres 发动机排量（升） year year of manufacture 制造年份 cyl number of cylinders 气缸数 trans type of transmission 变速器类型 drv the type of drive train, where f = front-wheel drive, r = rear wheel drive, 4 = 4wd 驱动类型，f是前驱，r是后驱，4是四驱 cty city miles per gallon 每加仑城市英里数 hwy highway miles per gallon 每加仑高速英里数 fl fuel type 燃油类型 class ‘type’ of car 车型大小 "],["附录.html", "11 附录 11.1 颜色", " 11 附录 11.1 颜色 二元配色 library(scales) show_col(c(&quot;#B47846&quot;,&quot;#4682B4&quot;)) 可用于KM曲线 "],["一些小技巧.html", "12 一些小技巧 12.1 R包的下载和加载", " 12 一些小技巧 12.1 R包的下载和加载 检查性加载 检查R包是否下载，没下载的话需要下载并加载。如果已下载的话，加载即可。 if(!require(tidyverse)) { install.packages(&quot;tidyverse&quot;, type = &quot;source&quot;)} "],["附录-1.html", "13 附录 13.1 颜色", " 13 附录 13.1 颜色 二元配色 library(scales) show_col(c(&quot;#B47846&quot;,&quot;#4682B4&quot;)) 可用于KM曲线 "],["infer包.html", "14 infer包 14.1 简介 14.2 卡方检验", " 14 infer包 14.1 简介 library(infer) specify() allows you to specify the variable, or relationship between variables, that you’re interested in. hypothesize() allows you to declare the null hypothesis. generate() allows you to generate data reflecting the null hypothesis. calculate() allows you to calculate a distribution of statistics from the generated data to form the null distribution. 本文所有vignette都使用gss（General Social Survey）数据集，共包含11个变量。 14.1.1 SPECIFY()指定被解释变量和解释变量 specify函数可以用来指定数据集中感兴趣的变量。如果你只对受访者的年龄感兴趣，你可以这样写: gss %&gt;% specify(response = age) ## Response: age (numeric) ## # A tibble: 500 × 1 ## age ## &lt;dbl&gt; ## 1 36 ## 2 34 ## 3 24 ## 4 42 ## 5 31 ## 6 32 ## 7 48 ## 8 36 ## 9 30 ## 10 33 ## # … with 490 more rows 如果您正在对一个比例或比例差异进行推理，则需要使用success参数来指定响应变量的哪个级别是成功的。例如，如果你对拥有大学学位的人口比例感兴趣，你可以使用以下代码: # specifying for inference on proportions gss %&gt;% specify(response = college, success = &quot;degree&quot;) ## Response: college (factor) ## # A tibble: 500 × 1 ## college ## &lt;fct&gt; ## 1 degree ## 2 no degree ## 3 degree ## 4 no degree ## 5 degree ## 6 no degree ## 7 no degree ## 8 degree ## 9 degree ## 10 no degree ## # … with 490 more rows 14.1.2 HYPOTHESIZE(): 指定零假设 14.1.3 GENERATE(): 14.2 卡方检验 "],["极大似然估计.html", "15 极大似然估计 15.1 自定义极大似然函数", " 15 极大似然估计 15.1 自定义极大似然函数 15.1.1 正态分布 正态分布的概率密度函数： \\[ f(x)=\\frac{1}{\\sqrt{2 \\pi}\\sigma} e ^{- \\frac{(x-\\mu)^{2}}{2\\sigma^2}} \\] 最大似然函数： \\[ \\begin{aligned} L(\\mu,\\sigma)&amp;=\\prod_{i=1}^{n} f(x_i,\\mu,\\sigma) \\\\ &amp;=\\prod_{i=1}^{n} \\frac{1}{\\sqrt{2 \\pi}\\sigma} e ^{- \\frac{(x-\\mu)^{2}}{2\\sigma^2}} \\\\ &amp; = (\\frac{1}{\\sqrt{2 \\pi} \\sigma})^n - \\sum_{i=1}^n \\frac{(x_i-\\mu)^2}{2\\sigma^2} \\end{aligned} \\] 对数最大似然函数： \\[ \\begin{aligned} lnL(\\mu,\\sigma)&amp;=n ln \\frac{1}{\\sqrt{2 \\pi} \\sigma} - \\sum_{i=1}^{n} \\frac{(x_i-\\mu)^2}{2\\sigma^2} \\end{aligned} \\] 得到对数最大似然函数后，再利用R中的optim函数求解对数最大似然函数取极值时对应的参数值 \\(\\mu\\)和\\(\\sigma\\)。 norm.fun&lt;- function(theta,x) # 创建似然函数 { mu&lt;- theta[1] sigma&lt;- theta[2] n&lt;- length(x) # 似然函数，再求其对数 logL&lt;- n*log( 1/( sqrt(2*pi)*sigma)) - sum((x-mu)^2)/(2*sigma^2) return(-logL) # 因为R中只有最小化函数optim(),我们只需要参数的值，最大化 logL 和最小化 -logL 一致的 } theta0=c(0,1) #初始化两个参数作为迭代初始值 X=1:50 #抽出的样本（这里我以1至50作为数据样本） result=optim(theta0,norm.fun,x=X) # 用R中内置的optim()最小化函数对 似然函数优化，求出最优值的两个参数u、sigma # 参数的值保存在result$&#39;par&#39; 中，有两个值，第一个是u 第二个是sigma result ## $par ## [1] 25.48969 14.43959 ## ## $value ## [1] 204.4154 ## ## $counts ## function gradient ## 81 NA ## ## $convergence ## [1] 0 ## ## $message ## NULL 在\\(lnL\\)取得最大值时（即\\(-lnL\\)取得最小值时），解出的\\(\\mu\\)的参数值为25.48969，\\(\\sigma\\)的参数估计值为14.43959，\\(-lnL\\)为204.4154。 15.1.2 指数分布 指数分布的概率密度函数： \\[ f(x)= \\begin{cases} \\lambda e^{-\\lambda x}, &amp; x&gt;0\\\\ 0, &amp; x\\le0 \\end{cases} \\] 最大似然函数： \\[ \\begin{aligned} L(\\lambda)&amp;=\\prod_{i=1}^{n} f(x_i,\\lambda) \\\\ &amp;=\\prod_{i=1}^{n}\\lambda e^{-\\lambda x} \\\\ &amp; = \\lambda^n - e^{-\\lambda \\sum_{i=1}^n x_i} \\end{aligned} \\] 对数最大似然函数： \\[ \\begin{aligned} lnL(\\lambda)&amp;=nln\\lambda -\\lambda \\sum_{i=1}^n x_i \\end{aligned} \\] 得到对数最大似然函数后，再利用R中的optim函数求解对数最大似然函数取极值时对应的参数值 \\(\\lambda\\)。 exp.fun &lt;- function(theta,x){ n &lt;- length(x) logL &lt;- n*log(theta)-theta*sum(x) return(-logL) } x=1:50 lamda=1e-2 result=optim(par = lamda,fn = exp.fun,x=X) #运行会有一些警告，说optim（）优化的结果不一定正确，但这里是正确的，不影响 ## Warning in optim(par = lamda, fn = exp.fun, x = X): one-dimensional optimization by Nelder-Mead is unreliable: ## use &quot;Brent&quot; or optimize() directly result ## $par ## [1] 0.03921875 ## ## $value ## [1] 211.9339 ## ## $counts ## function gradient ## 30 NA ## ## $convergence ## [1] 0 ## ## $message ## NULL 在\\(lnL\\)取得最大值时（即\\(-lnL\\)取得最小值时），解出的\\(\\lambda\\)的参数值为 0.03921875，\\(-lnL\\)为211.9339。 "],["正则表达式.html", "16 正则表达式 16.1 grep函数 16.2 元字符 16.3 常用文本处理函数 16.4 案例", " 16 正则表达式 16.1 grep函数 模式查询函数：查找符合某个条件的字符串/文本 ss &lt;- c(&quot;1314&quot;,&quot;abc&quot;,&quot;a b c&quot;,&quot;ABC&quot;,&quot;aB12c&quot;,&quot;13ab14c&quot;) grep(pattern = &quot;ab&quot;,x = ss) #ss向量中包含&quot;ab&quot;的索引 grep(pattern = &quot;ab&quot;,x = ss,ignore.case = TRUE) #忽略大小写 grep(pattern = &quot;ab&quot;,x = ss,value = TRUE) 16.1.1 函数参数 pattern x:字符向量 ignore.case：是否忽略大小写 value：是否返回值（而非索引） 16.1.2 模式（pattern）与匹配（match） 模式(pattern)：符合某种条件的“表达式”，如“姓张的同学”、“以数字开头的行” 匹配：用““模式”去比较/查找/筛选的过程称为“匹配” 16.2 元字符 表示自身的字符：字母、数字 1个任意字符：.（点号） 表示位置：^$ ^表示以xx开始，$表示以xx结束 表示数量：*?+ 星号代表任意数量，加号代表至少1个，问号代表0个或1个 括号类 [] 方括号表示含[]中的字符，注意[]与^联用表示否定，不含xx开头 {m,n} 花括号内可填一个数字或两个数字（表示范围） () 圆括号表示组合 转义符\\? \\*在元字符前加反斜杠（）进行转义。 其他： Tab(制表符) Enter(换行) 软换行 文字间隔符 任意空格符 不是空格键 任意文字字符（字母 汉字） 例子：任意字符（.点号）与 数量符号（*、+、?）的应用 ss &lt;- c(&quot;acb&quot;,&quot;a b&quot;,&quot;A b&quot;,&quot;a#b&quot;,&quot;a##b&quot;,&quot;ab&quot;) grep(pattern = &quot;ab&quot;,x = ss) #匹配ab grep(pattern = &quot;a.b&quot;,x = ss) #匹配ab中间有1个任意字符 grep(pattern = &quot;a..b&quot;,x = ss) #匹配ab中间有2个任意字符 grep(pattern = &quot;a.*b&quot;,x = ss) #匹配ab中间有任意数量个任意字符，数量可以为0 grep(pattern = &quot;a.+b&quot;,x = ss) #匹配ab中间有至少一个数量个任意字符 grep(pattern = &quot;a.?b&quot;,x = ss)#匹配ab中间有0个或1个数量个任意字符 ## [1] 6 ## [1] 1 2 4 ## [1] 5 ## [1] 1 2 4 5 6 ## [1] 1 2 4 5 ## [1] 1 2 4 6 例子：任意字符（.点号）与 数量符号（{}）的应用 ss &lt;- c(&quot;acb&quot;,&quot;a b&quot;,&quot;A b&quot;,&quot;a#b&quot;,&quot;a##b&quot;,&quot;ab&quot;) grep(pattern = &quot;a.{1,3}b&quot;,x = ss) #{}表示一个数字范围，匹配&quot;ab&quot;之间有1至3个任意字符 grep(pattern = &quot;a.{3}b&quot;,x = ss) #{}匹配&quot;ab&quot;之间有3个任意字符 ## [1] 1 2 4 5 ## integer(0) 例子：位置字符（^、$）的应用 ss &lt;- c(&quot;1314&quot;,&quot;abc&quot;,&quot;a b c&quot;,&quot;ABC&quot;,&quot;aB12c&quot;,&quot;13ab14c&quot;) grep(pattern = &quot;^1&quot;,x = ss) #匹配以1开始的索引 grep(pattern = &quot;4$&quot;,x = ss) #匹配以4结束的索引 ## [1] 1 6 ## [1] 1 例子：方括号（[]）的应用，注意方括号与^连用表否定 ss &lt;- c(&quot;a2b&quot;,&quot;a1cb&quot;,&quot;ab&quot;,&quot;a111b&quot;,&quot;a1b&quot;,&quot;acb&quot;) grep(pattern = &quot;a[2c]b&quot; ,x = ss) #ab中间有括号里面（2或c）的任意1个字符 grep(pattern = &quot;a[2c]*b&quot; ,x = ss) #ab中间有任意数量的括号里面（2或c）的任意1个字符 grep(pattern = &quot;a[0-9]b&quot;,x = ss) #&quot;ab&quot;中间有 “0到9”中的任意1个字符 grep(pattern = &quot;a[a-z]b&quot;,x = ss) #&quot;ab&quot;中间有 “a到z”中的任意1个字符 grep(pattern = &quot;a[^c]b&quot;,x = ss) ##这里的^表示否定，“非”的意思。&quot;ab&quot;中间没有以 “c”开头的字符 ## [1] 1 6 ## [1] 1 3 6 ## [1] 1 5 ## [1] 6 ## [1] 1 5 例子：圆括号的应用 可结合gsub函数，替换 ss &lt;- c(&quot;1314&quot;,&quot;abc&quot;,&quot;a b c&quot;,&quot;ABC&quot;,&quot;aB12c&quot;,&quot;13ab14c&quot;) grep(pattern = &quot;(13).4&quot;,x = ss) #匹配有13组合+任意1个字符+4的索引 grep(pattern = &quot;(13|13ab).4&quot;,x = ss) #匹配13或1314的组合+任意1个字符+4的索引 gsub(pattern = &quot;(13|13ab).4&quot;,replacement = &quot;XXXX&quot;,x = ss) #替换13或1314的组合+任意1个字符+4为“XXXX” gsub(pattern = &quot;(13|13ab).4&quot;,replacement = &quot;\\\\1&quot;,x = ss)#替换13或1314的组合+任意1个字符+4为第一次匹配的内容，\\\\1代表反向引用 ## [1] 1 ## [1] 1 6 ## [1] &quot;XXXX&quot; &quot;abc&quot; &quot;a b c&quot; &quot;ABC&quot; &quot;aB12c&quot; &quot;XXXXc&quot; ## [1] &quot;13&quot; &quot;abc&quot; &quot;a b c&quot; &quot;ABC&quot; &quot;aB12c&quot; &quot;13abc&quot; 转义符的应用 ss &lt;- c(&quot;acb&quot;,&quot;a?b&quot;,&quot;a??b&quot;) grep(pattern = &quot;a\\\\?b&quot;,x = ss) #\\\\?表示问号本身 grep(pattern = &quot;a\\\\?+b&quot;,x = ss) #\\\\?+表示至少一个问号 grep(pattern = &quot;^\\\\w+$&quot;,x = ss) #任意个字符开头并结束，及从头到尾全是字符（字母或汉字） grep(pattern = &quot;\\\\W+&quot;,x = ss) #含有非字符（符合 空格）成分 grep(pattern = &quot;\\\\d+&quot;,x = ss) #含有数字成分 grep(pattern = &quot;\\\\D+&quot;,x = ss) #含有非数字成分 ## [1] 2 ## [1] 2 3 ## [1] 1 ## [1] 2 3 ## integer(0) ## [1] 1 2 3 16.3 常用文本处理函数 length/nchar （向量元素的个数/每个向量元素字符的长度） 模式查询：grep/grepl （索引/返回逻辑值） 模式替换 sub/gsub 截取/修剪：substr/substring/strtrim 合并/拆分：paste/strsplit 转换/翻译：tolwer/toupper/chartr ss1 &lt;- c(1,12,123,&quot;abcdef&quot;) length(ss1) nchar(ss1) ## [1] 4 ## [1] 1 2 3 6 ss1 &lt;- c(1,12,123,&quot;abcdef&quot;) substr(&quot;abcdef&quot;, 2, 4) #截取字符第2到4位 substring(&quot;abcdef&quot;, first = 1:6, last = 1:6) # strtrim(ss1,width = 2) #修剪得到每个元素字符前两位 ## [1] &quot;bcd&quot; ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; ## [1] &quot;1&quot; &quot;12&quot; &quot;12&quot; &quot;ab&quot; ss1 &lt;- c(1,12,123,&quot;abcdef&quot;) paste(ss1,&quot;###&quot;) ## [1] &quot;1 ###&quot; &quot;12 ###&quot; &quot;123 ###&quot; &quot;abcdef ###&quot; paste(ss1,&quot;###&quot;,sep = &quot;-&quot;) #sep 两个字符间的分隔符 ## [1] &quot;1-###&quot; &quot;12-###&quot; &quot;123-###&quot; &quot;abcdef-###&quot; paste(ss1,&quot;###&quot;,sep = &quot;-&quot;,collapse = &quot;;&quot;) #collapse 将多个向量元素融合 ## [1] &quot;1-###;12-###;123-###;abcdef-###&quot; strsplit(&quot;abc def&quot;,split = &quot;&quot;) #每个字符拆分 strsplit(&quot;abc def&quot;,split = &quot; &quot;) #空格符拆分 strsplit(&quot;abc def&quot;,split = &quot; +&quot;) #split可跟正则表达式，“空格+”表示一个或多个空格拆分空格符拆分 ss1 &lt;- c(1,12,123,&quot;abcdef&quot;) strsplit(ss1,split = &quot;&quot;) ## [[1]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot; &quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; ## ## [[1]] ## [1] &quot;abc&quot; &quot;def&quot; ## ## [[1]] ## [1] &quot;abc&quot; &quot;def&quot; ## ## [[1]] ## [1] &quot;1&quot; ## ## [[2]] ## [1] &quot;1&quot; &quot;2&quot; ## ## [[3]] ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; ## ## [[4]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; 16.4 案例 16.4.1 查找指定目录下的jpg图像文件（list.files函数） dic dirctory=&quot;../front_end/fig/&quot; file_name=list.files(path = dirctory, #文件路径 pattern = &quot;\\\\.jpg$&quot;, #正则表达式 recursive = TRUE, #是否迭代子目录 full.names = TRUE, #是否显示文件全部路径 ignore.case = TRUE) #是否忽略大小写 file_name file.size(file_name) #查看文件大小，单位为KB ## [1] &quot;../front_end/fig//appendix/100-01.jpg&quot; ## [2] &quot;../front_end/fig//appendix/100-02.jpg&quot; ## [3] &quot;../front_end/fig//appendix/100-03.jpg&quot; ## [4] &quot;../front_end/fig//case/80-01.jpg&quot; ## [5] &quot;../front_end/fig//case/80-02.jpg&quot; ## [6] &quot;../front_end/fig//case/80-03.jpg&quot; ## [7] &quot;../front_end/fig//case/80-04.jpg&quot; ## [8] &quot;../front_end/fig//case/80-05.jpg&quot; ## [9] &quot;../front_end/fig//case/80-06.jpg&quot; ## [10] &quot;../front_end/fig//case/80-07.jpg&quot; ## [11] &quot;../front_end/fig//CSS/1-01.jpg&quot; ## [12] &quot;../front_end/fig//CSS/1-02.jpg&quot; ## [13] &quot;../front_end/fig//CSS/1-03.jpg&quot; ## [14] &quot;../front_end/fig//CSS/101-01.jpg&quot; ## [15] &quot;../front_end/fig//CSS/19-01.jpg&quot; ## [16] &quot;../front_end/fig//CSS/19-02.jpg&quot; ## [17] &quot;../front_end/fig//CSS/19-03.jpg&quot; ## [18] &quot;../front_end/fig//CSS/19-04.jpg&quot; ## [19] &quot;../front_end/fig//CSS/19-05.jpg&quot; ## [20] &quot;../front_end/fig//CSS/19-06.jpg&quot; ## [21] &quot;../front_end/fig//CSS/19-20.jpg&quot; ## [22] &quot;../front_end/fig//CSS/19-21.jpg&quot; ## [23] &quot;../front_end/fig//CSS/19-22.jpg&quot; ## [24] &quot;../front_end/fig//CSS/19-23.jpg&quot; ## [25] &quot;../front_end/fig//CSS/20-01.jpg&quot; ## [26] &quot;../front_end/fig//CSS/20-02.jpg&quot; ## [27] &quot;../front_end/fig//CSS/20-10.jpg&quot; ## [28] &quot;../front_end/fig//CSS/20-11.jpg&quot; ## [29] &quot;../front_end/fig//CSS/20-12.jpg&quot; ## [30] &quot;../front_end/fig//CSS/20-15.jpg&quot; ## [31] &quot;../front_end/fig//CSS/20-16.jpg&quot; ## [32] &quot;../front_end/fig//CSS/20-17.jpg&quot; ## [33] &quot;../front_end/fig//CSS/20-18.jpg&quot; ## [34] &quot;../front_end/fig//CSS/20-20.jpg&quot; ## [35] &quot;../front_end/fig//CSS/20-21.jpg&quot; ## [36] &quot;../front_end/fig//CSS/20-22.jpg&quot; ## [37] &quot;../front_end/fig//CSS/20-25.jpg&quot; ## [38] &quot;../front_end/fig//CSS/20-26.jpg&quot; ## [39] &quot;../front_end/fig//CSS/21-01.jpg&quot; ## [40] &quot;../front_end/fig//CSS/21-02.jpg&quot; ## [41] &quot;../front_end/fig//CSS/21-03.jpg&quot; ## [42] &quot;../front_end/fig//CSS/21-04.jpg&quot; ## [43] &quot;../front_end/fig//CSS/21-05.jpg&quot; ## [44] &quot;../front_end/fig//CSS/21-06.jpg&quot; ## [45] &quot;../front_end/fig//CSS/21-07.jpg&quot; ## [46] &quot;../front_end/fig//CSS/21-08.jpg&quot; ## [47] &quot;../front_end/fig//CSS/21-09.jpg&quot; ## [48] &quot;../front_end/fig//CSS/21-10.jpg&quot; ## [49] &quot;../front_end/fig//CSS/21-14.jpg&quot; ## [50] &quot;../front_end/fig//CSS/21-15.jpg&quot; ## [51] &quot;../front_end/fig//CSS/21-16.jpg&quot; ## [52] &quot;../front_end/fig//CSS/21-17.jpg&quot; ## [53] &quot;../front_end/fig//CSS/21-18.jpg&quot; ## [54] &quot;../front_end/fig//CSS/5-01.jpg&quot; ## [55] &quot;../front_end/fig//CSS/6-01.jpg&quot; ## [56] &quot;../front_end/fig/1-1.jpg&quot; ## [57] &quot;../front_end/fig/1-10.jpg&quot; ## [58] &quot;../front_end/fig/1-11.jpg&quot; ## [59] &quot;../front_end/fig/1-12.jpg&quot; ## [60] &quot;../front_end/fig/1-2.jpg&quot; ## [61] &quot;../front_end/fig/1-20.jpg&quot; ## [62] &quot;../front_end/fig/1-21.jpg&quot; ## [63] &quot;../front_end/fig/1-22.jpg&quot; ## [64] &quot;../front_end/fig/1-23.jpg&quot; ## [65] &quot;../front_end/fig/1-3.jpg&quot; ## [66] &quot;../front_end/fig/1-30.jpg&quot; ## [67] &quot;../front_end/fig/1-31.jpg&quot; ## [68] &quot;../front_end/fig/1-32.jpg&quot; ## [69] &quot;../front_end/fig/1-33.jpg&quot; ## [70] &quot;../front_end/fig/1-4.jpg&quot; ## [71] &quot;../front_end/fig/1-41.jpg&quot; ## [72] &quot;../front_end/fig/1-5.jpg&quot; ## [73] &quot;../front_end/fig/1-51.jpg&quot; ## [74] &quot;../front_end/fig/1-6.jpg&quot; ## [75] &quot;../front_end/fig/1-7.jpg&quot; ## [76] &quot;../front_end/fig/17-02.jpg&quot; ## [77] &quot;../front_end/fig/17-11.jpg&quot; ## [78] &quot;../front_end/fig/18-01.jpg&quot; ## [1] 13029 11057 49485 58444 19010 7625 28207 13162 87024 23939 ## [11] 13528 9028 3909 147563 98126 61088 35949 24838 22270 14697 ## [21] 10954 13845 37489 20298 10215 11651 22618 17758 14780 25265 ## [31] 22767 28288 36725 18726 15727 69040 11881 59069 17018 43281 ## [41] 11027 14447 40416 30519 53498 21247 36862 19355 11262 14066 ## [51] 7132 10024 5582 6286 17656 92362 14271 6913 7374 58411 ## [61] 45855 7360 8515 13057 56081 14049 13009 22879 26817 50769 ## [71] 71105 99416 51007 144687 58105 936815 10285 23057 tolower(c(&quot;aBc&quot;,&quot;ABCxx&quot;)) #全部小写 toupper(c(&quot;aBc&quot;,&quot;ABCxx&quot;)) #全部大写 ## [1] &quot;abc&quot; &quot;abcxx&quot; ## [1] &quot;ABC&quot; &quot;ABCXX&quot; xseq &lt;- &quot;ATCGCCC&quot; chartr(old = &quot;ATCG&quot;,new = &quot;UAGC&quot;,x = xseq) #旧字符翻译成新字符，如A翻译成U，T翻译成A... ## [1] &quot;UAGCGGG&quot; 16.4.2 全宋词 gsub(pattern = &quot;.\\\\s&quot;,replacement = &quot;&quot;,x = songci) #去除文本向量中所有空格符 sentence=grep(pattern = &quot;|&quot;,x = songci,value = TRUE) #查找含“杨”或“柳”的句子 tail(sentence) 16.4.3 SCI（筛选行） 筛选出杂志名包含NATURE，且19年IF&gt;3的行 grepl函数返回TURE or FALSE，表示向量中每个元素是否满足正则表达式 data ss1 &lt;- grepl(pattern = &quot;nature&quot;,x = data$tittle,ignore.case = TRUE) ss2 &lt;- data$IF &gt; 3 dt[ss1 &amp; ss2,] "],["一些自定义函数.html", "17 一些自定义函数 17.1 数据处理 17.2 统计相关", " 17 一些自定义函数 17.1 数据处理 17.1.1 分组排序并排名 单个分组变量进行排序 rank_in_group &lt;- function(.data,.group_var,.rank_var){ .data %&gt;% arrange({{.group_var}}, {{.rank_var}}) %&gt;% ##先根据group和var进行排序 group_by({{.group_var}}) %&gt;% mutate(n = rank({{.rank_var}}, ties.method = &quot;first&quot;), ##生成n=每个分组中每个观测的排名 N = max(n)) ##N=每个分组的观测数 } iris %&gt;% rank_in_group(.group_var = Species,.rank_var = Sepal.Length) ## # A tibble: 150 × 7 ## # Groups: Species [3] ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species n N ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; ## 1 4.3 3 1.1 0.1 setosa 1 50 ## 2 4.4 2.9 1.4 0.2 setosa 2 50 ## 3 4.4 3 1.3 0.2 setosa 3 50 ## 4 4.4 3.2 1.3 0.2 setosa 4 50 ## 5 4.5 2.3 1.3 0.3 setosa 5 50 ## 6 4.6 3.1 1.5 0.2 setosa 6 50 ## 7 4.6 3.4 1.4 0.3 setosa 7 50 ## 8 4.6 3.6 1 0.2 setosa 8 50 ## 9 4.6 3.2 1.4 0.2 setosa 9 50 ## 10 4.7 3.2 1.3 0.2 setosa 10 50 ## # … with 140 more rows 多个分组变量进行排序 rank_in_groups &lt;- function(.data, .rank_var, ...) { rank_var &lt;- enquo(.rank_var) group_vars &lt;- enquos(...) # Get a list of quoted dots .data %&gt;% arrange(!!!group_vars,!!rank_var) %&gt;% group_by(!!!group_vars) %&gt;% # Unquote-splice the list mutate(n = rank(!!rank_var, ties.method = &quot;first&quot;), ##生成n=每个分组中每个观测的排名 N = max(n)) } mtcars %&gt;% rank_in_groups(mpg,vs,gear) ##mpg是排序变量，vs和gear是分组变量 ## # A tibble: 32 × 13 ## # Groups: vs, gear [6] ## mpg cyl disp hp drat wt qsec vs am gear carb n N ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 10.4 8 472 205 2.93 5.25 18.0 0 0 3 4 1 12 ## 2 10.4 8 460 215 3 5.42 17.8 0 0 3 4 2 12 ## 3 13.3 8 350 245 3.73 3.84 15.4 0 0 3 4 3 12 ## 4 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 4 12 ## 5 14.7 8 440 230 3.23 5.34 17.4 0 0 3 4 5 12 ## 6 15.2 8 276. 180 3.07 3.78 18 0 0 3 3 6 12 ## 7 15.2 8 304 150 3.15 3.44 17.3 0 0 3 2 7 12 ## 8 15.5 8 318 150 2.76 3.52 16.9 0 0 3 2 8 12 ## 9 16.4 8 276. 180 3.07 4.07 17.4 0 0 3 3 9 12 ## 10 17.3 8 276. 180 3.07 3.73 17.6 0 0 3 3 10 12 ## # … with 22 more rows 17.2 统计相关 17.2.1 汇总数据t检验 t.test2 &lt;- function(m1,m2,s1,s2,n1,n2,m0=0,equal.variance=FALSE) { if( equal.variance==FALSE ) { se &lt;- sqrt( (s1^2/n1) + (s2^2/n2) ) # welch-satterthwaite df df &lt;- ( (s1^2/n1 + s2^2/n2)^2 )/( (s1^2/n1)^2/(n1-1) + (s2^2/n2)^2/(n2-1) ) } else { # pooled standard deviation, scaled by the sample sizes se &lt;- sqrt( (1/n1 + 1/n2) * ((n1-1)*s1^2 + (n2-1)*s2^2)/(n1+n2-2) ) df &lt;- n1+n2-2 } t &lt;- (m1-m2-m0)/se dat &lt;- c(m1-m2, se, t, 2*pt(-abs(t),df)) ##pt函数可以打印p值 names(dat) &lt;- c(&quot;Difference of means&quot;, &quot;Std Error&quot;, &quot;t&quot;, &quot;p-value&quot;) return(dat) } # m1, m2: the sample means # s1, s2: the sample standard deviations # n1, n2: the same sizes # m0: the null value for the difference in means to be tested for. Default is 0. # equal.variance: whether or not to assume equal variance. Default is FALSE. usage: ## Difference of means Std Error t p-value ## 0.01183358 0.11348530 0.10427416 0.91704542 17.2.2 卡方检验 chisq_test &lt;- function(data,x1,x2,correct=FALSE,fisher=FALSE){ library(dplyr) X&lt;- data %&gt;% ##先将原始数据变换为列联表形式 select(x1,x2) %&gt;% table() if(fisher==FALSE){ ## 如果fisher参数是F，进行卡方检验 result &lt;- chisq.test(x = X,correct = correct) } else{ ## 如果fisher参数是T，进行fisher精确检验 result &lt;- fisher.test(x = X) } ## 报告卡方值和p值 list(squared.value=result$statistic, p.value=result$p.value ) } "]]
